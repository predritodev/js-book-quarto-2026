# Soluciones {.unnumbered} 

## Reto #1 {#sec-sol-array-1}

La respuesta del [Reto #1](#sec-array-1) es:

**A. `[1, 33, 9, -2]`**

**Explicación:**

El objeto `Number` de JavaScript puede convertir los los valores de un arreglo a números, pero hay que tener cuidado con tipos `boolean`, `undefined` o `null`.

Este hack es muy útil cuando tenemos un arreglo de strings que queremos convertir a números.

---

## Reto #2 {#sec-sol-array-2}

La respuesta del [Reto #2](#sec-array-2) es:

**D. `Pera`**

**Explicación:**

Para usar la desestructuración en arreglos es importante tener en cuenta los índices de los elementos. Por ello para acceder a `Pera` en el arreglo `fruits` haríamos algo como:

```js
const [, , , pear]  = fruits;
```

Donde cada `,` representa el salto de un índice del arreglo.

Para una sistaxis mas breve podemos usar esto:

```js
const { 3:pear } = fruits;
```

Donde el `3` representa las posiciones que deseamos saltar.

Nota que aunque frutas sea un arreglo usamos `{}` para la desestructuración.

---

## Reto #3 {#sec-sol-array-3}

**Explicación:**

JavaScript tiene una peculiaridad que se denomina **coerción de tipos**. Al intentar realizar algún tipo de operación o comparación ambigua el lenguaje tratará de realizar una conversión de tipos implícita para poder devolver un resultado más o menos lógico, el problema acá radica en que muchas veces el resultado obtenido será diferente al esperado.

Veamos el primer ejemplo:

```js
console.log(false == 0)
```

En JavaScript existen lo que denomina **valores `falsy`** y son los siguientes:

* `0`
* `-0`
* `0n`
* `false`
* `null`
* `undefined`
* `NaN`
* Cualquier tipo de cadena vacía: `'', ""`

Todos estos valores son considerados como falsos para el lenguaje.

Como `0` es un **valor falsy** entonces, aunque no lo veamos, JavaScript hace algo como esto tras bambalinas:

```js
console.log(false == false)
```

Y como estamos usando el operador de comparación débil `==` nos limitamos a comparar los valores **más NO los tipos de datos**.

En conclusión, la respuesta es `true` por **coerción de tipos**

Pasemos al siguiente ejemplo:

```js
console.log(false === 0)
```

Al usar el **operador estricto de comparación** `===` comparamos tanto el **valor** como el **tipo de dato**, `false` es de tipo `boolean` y `0` es de tipo `number` ergo, la respuesta es `false`.

En otras palabras, también es correcto afirmar que al usar el `===` JavaScript no hace **coerciones de tipo**, por ello es ampliamente sugerido usarlo.

--- 

## Reto #4 {#sec-sol-array-4}

**Explicación:**

Si bien `null` y `undefined` son valores `falsy` al momento de que JavaScript haga **coerciones de tipo** pasa algo raro, esto se debe a que tanto `null` como `undefined` sólo son **iguales** a sí mismos y entre ellos:

```js
console.log(null == null); // true
console.log(undefined == undefined); // true
console.log(undefined == null); // true
```

Solo en estos casos obtendremos como salida un `true`.

Pero es recomendable usar siempre el **operador estricto de igualdad** `===`:

```js
console.log(null === null); // true
console.log(undefined === undefined); // true
console.log(undefined === null); // false
```

Esto para evitar que JavaScript haga **coerciones de tipos** y obtengamos resultados no esperados.

--- 

## Reto #5 {#sec-sol-array-5}

**Explicación:**

`NaN` o "Not a Number" es el resultado que nos brinda JavaScript cuando intentamos hacer una operación que no tiene sentido, y por ende el resultado no será un número, por ejemplo:

```js
console.log(Math.sqrt(-1)) // NaN
console.log(10 / "hola") // NaN
console.log(Number("hola")) // NaN
```

Obtener la raiz cuadrada de `-1`, dividir un entero entre una cadena y convertir una cadena a un número son algunas operaciones que nos dan `NaN`.

Ahora bien, cuando intentamos hacer `console.log(NaN === NaN)`, aún usando el operador `===` obtenemos `false` ya que el `NaN` de una operación no puede ser igual al `NaN` de otra. Dos `NaN` nunca serán iguales por este motivo. 

En conclusión, no existe ningún valor en JavaScript que igualado a `NaN` sea `true`, ni siquiera el mismo `NaN`. Esto es una característica propia del lenguaje.

---

## Reto #6 {#sec-sol-array-6}

La respuesta del [Reto #6](#sec-array-6) es:

**A. `Hello`**

**Explicación:**

Cuando aplicamos el operador de asignación `=` entre objetos pensado que así lograremos obtener una copia del mismo estamos cayendo en un **error de novato**.

Recuerda que los objetos se manejan segun su **referencia** y no por su **valor** como lo hacen los tipos primitivos del lenguaje, esto significa que al hacer esto:

```js
let c = { greeting: "Hey!" };
let d;

d = c;
```

No solo estamos copiando los valores del objeto `c` al objeto `d` sino que también copiamos su **referencia en memoria**. Esta referencia es la dirección donde dicho objeto se almacenerá en el disco duro del ordenador; en JavaScript al ser un lenguaje de alto nivel no podemos acceder a dichas direcciones como en lenguajes de bajo nivel como por ejemplo **lenguaje ensamblador** (aunque en Python si se pude con la función `id()` pero este no es un libro de Python).

Dicho en otras palabras, las direcciones de memoria del objeto `c` y del objeto `d` son las mismas, apuntan a la misma dirección, por ello, cuando intentamos modificar el objeto `c`:

```js
c.greeting = "Hello";
```

En realidad, estamos modificando ambos objetos.

Para crear copias de objetos de manera segura se recomienda usar el **spread operator** con su sintaxis de tres puntos `...`

```js
let c = { greeting: "Hey!" };
let d;

d = {...c};

c.greeting = "Hello";
console.log(d.greeting); // Hey!
console.log(c.greeting); // Hello
```

Este método solo sirve para copiar objetos en el primer nivel, si deseamos realizar copias de objetos anidados se puede recurrir a otras alternativas como por ejemplo `JSON.stringify`.

---

## Reto #7 {#sec-sol-array-7}

La respuesta del [Reto #7](#sec-array-7) es:

**A. `1`, `false`**

**Explicación:**

El el primer caso, el operador `+` intenta convertir a `number` al valor `true`, por **coerción de tipos** JavaScript infiere a `true` como 1. 

En el segundo caso, intentamos negar un `string`, dicho `string` es un valor truthy, por ende, nuevamente por **coerción de tipos** JavaScript infiere al `string` "Lydia" como `true`, y la negación de `true` es `false`.

---

## Reto #8 {#sec-sol-array-8}

La respuesta del [Reto #8](#sec-array-8) es:

**C. `true`, `false`, `false`**

**Explicación:**

En el primer `console.log`:

```js
console.log(a == b);
```

Vemos que hacemos una comparación débil con el operador `==`, esto significa que **solo compararemos los valores de `a` y `b`**, por ende obtendremos un `true`.

En el segundo `console.log`:

```js
console.log(a === b);
```

Hacemos una comparación estricta usando el operador `===`, esto significa que compararemos **valores** y **tipos de datos**, `a` y `b` tienen el mismo valor, pero `a` es de tipo `number` y `b` esta siendo inicializada usando el contructor `Number`, por ende es un objeto; entonces obtendremos un `false`.

En el tercer `console.log`

```js
console.log(b === c);
```

Al igual que el caso anterior, intentamos comparar de manera estricta un objeto contra un número, entonces tendremos como resultado un `false`.

**Conclusión: trata de usar simpre `===`**

---

## Reto #9 {#sec-sol-array-9}

La respuesta del [Reto #9](#sec-array-9) es:

**A. `No pasa nada, es totalmente correcto.`**

**Explicación:**

WTF! Cuando vi que hacer esto es posible casi me caigo de la silla. Expliquemos por que:

Oiste o leiste alguna vez esta frase: **"Todo en JavaScript es un objeto"** Dejame decirte que no es mentira, literalmente todo es un objeto, todo lo que no sea un tipo primitivo en JavaScript es un objeto, desde arreglos, los propios objetos claro, las promesas, y también las **funciones**.

En el ejemplo, la función `bark()` funciona completamente bien:

```js
function bark() {
  console.log("Woof!");
}
console.log(bark()) // Woof!
```

Y si intentamos acceder a la propiedad `animal` no tendremos ningún problema:

```js
function bark() {
  return "Woof!"
}

bark.animal = "dog";
console.log(bark.animal); // dog
```
Este es un comportamiento muy jocoso del lenguaje y esta bueno saber que es posible hacer estas cosas aunque no tenga muchos casos de uso.

---

## Reto #10 {#sec-sol-array-10}

La respuesta del [Reto #10](#sec-array-10) es:

**A. `{}`**

**Explicación:**

En la primera línea declaramos `let greeting;`, al declarar una variable con `let` sin inicializarla, esta toma el valor de `undefined`.

En la segunda línea, se comete un error de tipeo `greetign = {};`, pero como la variable no esta declarada ni con `var`, `let` o `const`; Javascript tras bambalinas hace algo como lo siguiente aunque el programador no lo vea:

```js
var greetign = {}; // Typo!
```

Entonces `greetign` se crea como **variable global**, en el navegador en el objeto `window` y en un entorno de Node.js en el objeto `global`.

El código final se veria así:

```js
let greeting; // undefined
var greetign = {}; // Typo!
console.log(greetign); // {}
```

::: {.callout-tip}
## Tip

Siempre declara tus variables con `let` o `const`. Deja que `var` muera y no la uses más.
:::

---

## Reto #11 {#sec-sol-array-11}

La respuesta del [Reto #11](#sec-array-11) es:

**C. `"11111"`, `10`**

**Explicación:**

Vayamos por partes.

En el primer `console.log(x + y)`:
Intentamos sumar las variables `x` y `y`, pero `x` es una cadena y `y` es un número, por **coersión de tipos** la operación ya no será una suma aritmética sino una concatenación de cadenas. Dicho en otras palabras la variable `y` sera convetida implicitamente por el interprete de JavaScript a cadena, por lo que el resultado será `"11111"`.

En el segundo `console.log(y - z)`:
Intentamos restar las variables `y` y `z`, pero `y` es una cadena y `z` es un número, por **coersión de tipos** la operación será una resta artimética de toda la vida. Dicho en otras palabras la variable `z` sera convetida implicitamente por el interprete de JavaScript a número, por lo que el resultado será `10`.

::: {.callout-tip}
## Tip
En JavaScript el operador `+` puede significar una suma o una concatenación según el caso de uso, pero el operador `-` siempre significara una resta artimética.
:::

---

## Reto #12 {#sec-sol-array-12}

La respuesta del [Reto #12](#sec-array-12) es:

**C. `Hmm... You don't have an age I guess`**

**Explicación:**

Cuando comparamos objetos hay que tener mucho cuidado.

Comparar primitivos es sencillo, pero recuerda que los objetos se almacenan en memoria teniendo en cuenta su **referencia** y no su **valor**.

Dicho esto, el objeto que pasamos como argumento a `checkAge` es el objeto `{ age: 18 }`, este es diferente al objeto que evaluamos en los `if` de la función, por más que usemos comparación estricta, seguirán siendo objetos diferentes **por que sus referencias son diferentes**:

```js
{ age: 18 } == { age: 18 } //false
{ age: 18 } === { age: 18 } //false
```

Entonces nunca se cumple ni la condición del `if` ni del `else if` y se ejecuta el `else` directamente, imprimiendo `Hmm... You don't have an age I guess` como resultado final.

---

## Reto #13 {#sec-sol-array-13}

La respuesta del [Reto #13](#sec-array-13) es:

**C. `object`**

**Explicación:**

Cuando usamos la sintaxis de `...` en los parámetros de una función (REST parameter desde ES6) convertimos a dicho parámetro en un arreglo. Entonces es tentador marcar la opción **B. `"array"`** pero esto sería un **error de novato**. En JavaScript no existe el tipo de dato `array`, para **tipos no primitivos** el lenguaje los evalua como `object`. Por ese motivo la respuesta correcta es la opción **C. `object`**.

---

## Reto #14 {#sec-sol-array-14}

La respuesta del [Reto #14](#sec-array-14) es:

**D. `string`**

**Explicación:**

El operador `+` por lo general intentará realizar una concateneción, en este caso, el interprete de JavaScript, por **coerción de tipos** intentará convertir los arreglos a cadenas de texto, haciendo algo como esto aunque no lo veamos:

```js
console.log(typeof ([].toString() + [].toString())); 
console.log(typeof ("" + ""));
console.log(typeof ("")); //string
```

---

## Reto #15 {#sec-sol-array-15}

La respuesta del [Reto #15](#sec-array-15) es:

**C: `true`, `true`, `false`, `true`**

**Explicación:**

En el objeto:

```js
const obj = { 1: "a", 2: "b", 3: "c" };
obj.hasOwnProperty("1"); //true
obj.hasOwnProperty(1); //true
```

El método `hasOwnProperty` propio de los objetos retorna un `boolean` dependiendo **si la key del objeto existe o no**.

Lo que hay que tener en cuenta es que las claves de un objeto siempre son de tipo `string` aunque no lo especifiquemos.

En el `set`:

```js
const set = new Set([1, 2, 3, 4, 5]);
set.has("1"); //false
set.has(1); //true
```

Esto no funciona como en un objeto, recuerda que un `set` es como un tipo de arreglo de valores no repetidos. Por ello `1` `string` no concuerda con `1` `number`.

---

## Reto #16 {#sec-sol-array-16}

La respuesta del [Reto #16](#sec-array-16) es:

**C: `{ a: "three", b: "two" }`**

**Explicación:**

Cuando en un objeto tenemos keys repetidas, estas se sobre escriben respetando el orden alfabético. Por ello la respuesta es C.

---

## Reto #17 {#sec-sol-array-17}

La respuesta del [Reto #17](#sec-array-17) es:

**A. "Just give Lydia pizza already!"**

**Explicación:**

`String` es el contructor que tiene JavaScript para gestionar las cadenas de texto. En el ejemplo se agrega la función `giveLydiaPizza` al prototipo de las cadenas, con ello, esta función estará disponible para todas las cadenas.

Si intentamos hacer algo como lo siguiente:

```js
String.prototype.giveLydiaPizza = () => {
  return "Just give Lydia pizza already!";
};

const bool = true;
console.log(bool.giveLydiaPizza()); 
//TypeError: bool.giveLydiaPizza is not a function 
```

Obtendremos un error, `giveLydiaPizza` solo se puede usar con un `string`. 

---

## Reto #18 {#sec-sol-array-18}

La respuesta del [Reto #18](#sec-array-18) es:

**B. `First`, `Third`, `Second`**

**Explicación:**

Para comprender la respuesta es necesario entender temas estructurales del lenjuage, es decir, ir a las bases de JavaScript y conocer conceptos como **Event Loop**, **Call Stack**, **Task Queue**, **Web API's** entre otros. 

Para poder darse cuenta, el secreto que puedo compartirte es concentrarse en el orden de las llamadas a las funciones, es decir en estas líneas:

```js
bar(); // primero llamamos a bar()
foo(); // luego a foo()
baz(); // finalmente baz()
```

Primero, llamamos a la función `bar()` que tiene en su cuerpo un `setTimeout` puedes pensar que al carecer de delay en ms este código se ejecuta de inmediato, pero no es así, ya que `setTimeout` es una `Web API`, por este motivo este código debe almacenarse en lo que llamamos **Task Queue**.

Segundo, llamamos a la función `foo()`, que contiene código síncrono, por ende pasa directamente al **Call Stack** y mostramos por consola `First`.

Tercero, llamamos a la función `baz()`, que contiene código síncrono nuevamente, por ello pasa al **Call Stack** y mostramos por consola `Third`.

Ahora, el algotirmo del **Even Loop** se da cuenta que no hay mas funciones por llamar, y verifica que el **Call Stack** esta vacio, entonces busca si hay algo en el **Task Queue**, y oh sorpresa, esta nuestro `setTimeout`, entonces lo pasa al **Call Stack** para finalmente mostrar por consola `Second`

Es complicado de entender al principio, te dejo una [demostración gráfica](https://www.jsv9000.app/?code=Y29uc3QgZm9vID0gKCkgPT4gY29uc29sZS5sb2coIkZpcnN0Iik7CmNvbnN0IGJhciA9ICgpID0%2BIHNldFRpbWVvdXQoKCkgPT4gY29uc29sZS5sb2coIlNlY29uZCIpKTsKY29uc3QgYmF6ID0gKCkgPT4gY29uc29sZS5sb2coIlRoaXJkIik7CgpiYXIoKTsKZm9vKCk7CmJheigpOw%3D%3D) 

---

## Reto #19 {#sec-sol-array-19}

La respuesta del [Reto #19](#sec-array-19) es:

**B. `string`**

**Explicación:**

Esta pregunta es un poco trampa. Pero la respuesta es chistosa:

`typeof 1` regresa `"number"`, literalemnte la cadena `"number"`, entonces tendriamos `typeof "number"` y esto da obiamente `string`. 

---

## Reto #20 {#sec-sol-array-20}

La respuesta del [Reto #20](#sec-array-20) es:

**C. `[1, 2, 3, 7 x empty, 11]`**

**Explicación:**

JavaScript no arroja ningún error, crea valores `undefined` hasta completar los índices pertinentes, luego muestra el último valor creado, en este caso `11`.

Dependiendo en que entorno de ejecución se ejecute el código puede variar un poco la salida, una respuesta valida también sería:

```js
[1, 2, 3, undefined, undefined, undefined, undefined, 
undefined, undefined, undefined, 11]
```
---

## Reto #21 {#sec-sol-array-21}

La respuesta del [Reto #21](#sec-array-21) es:

**C. `[1, 2, 0, 1, 2, 3]`**

**Explicación:**

`acc` se inicializa con `[1, 2]`. En el `return` de la función concatenamos este valor de inicialización con el arreglo anidado, arreglo por arreglo.

---

## Reto #22 {#sec-sol-array-22}

La respuesta del [Reto #22](#sec-array-22) es:

**B. `false`, `false`, `true`**

**Explicación:**

El operador `!!` realiza una doble negación.

En el primer caso, por **coerción de tipos**, `null` es un valor **falsy**, si lo negamos 2 veces, tendríamos `false`.

En el segundo caso, por **coerción de tipos**, `""` es un valor **falsy**, si lo negamos 2 veces tendríamos `false`.

Por último, el tercer caso, y nuevamente por **coerción de tipos**, el valor `1` es un valor `truthy`, si lo negamos 2 veces, obtendremos `true`.

Dicho de otra manera, el operador de doble negación realiza una conversión de tipo a booleano, es decir, transforma cualquier valor en su equivalente booleano.

---

## Reto #23 {#sec-sol-array-23}

La respuesta del [Reto #23](#sec-array-23) es:

**C. `Hi cada segundo`**

**Explicación:**

La función `setInterval` es una `Web API` que recibe un intervalo en milisegundos, e imprime el cuerpo de la función en dicho intervalo.

---

## Reto #24 {#sec-sol-array-24}

La respuesta del [Reto #24](#sec-array-24) es:

**A. `["O", "s", "c", "a", "r"]`**

**Explicación:**

Un `string` es un elemento iterable en JavaScript, por ende es posible usar el `spread operator` directamente obteniendo la propagación de la cadena letra por letra.

---

## Reto #25 {#sec-sol-array-25}

La respuesta del [Reto #25](#sec-array-25) es:

**D. `[{ name: "Lydia" }]`**

**Explicación:**

Cuando hacemos:

```js
const members = [person];
```

En realidad estamos realizando una copia a la referencia de `person`, tanto `person` como `members` apuntan a la misma referencia del objeto en memoria.

Por este motivo al hacer:

```js
person = null;
```

Cambiamos el valor de `person` a `null` pero `members` conserva la referencia al objeto y por ello también su valor.

---

## Reto #26 {#sec-sol-array-26}

La respuesta del [Reto #26](#sec-array-26) es:

**B. `"name"`, `"age"`**

**Explicación:**

El bucle `for...in` en JavaScript aplicado sobre un objeto nos brinda las llaves del objeto per se. Recuerda que aunque no lo veamos el lenguaje interpreta las llaves de los objetos como un `string` a no ser que dichas llaves sean de tipo `symbol`. 

Si vemos esto:

```js
const person = {
  name: "Carla",
  age: 26
};
```

JavaScript verá esto:

```js
const person = {
  "name": "Carla",
  "age": 26
};

```
Es por este motivo que cuando ejecutamos: 

```js
for (const item in person) {
  console.log(item);
}
```

La variable `item` tendrá el valor de cada llave del objeto en cada iteración; en el ejemplo al tener solo 2 llaves, primer `item` valdrá `name` y luego `age`.

---

## Reto #27 {#sec-sol-array-27}

La respuesta del [Reto #27](#sec-array-27) es:

**B. `"75"`**

**Explicación:**

El código JavaScript se ejecuta de arriba hacia abajo y de izquierda a derecha.

Primero realizamos la suma `3 + 4`, puesto que ambos son  de tipo `number` obtenemos `7`.

Ahora tenemos `7 + "5"`, como `"5"` es de tipo `string`, ahora realizamos una concatenación de valores y por `coerción de tipos` el resultado final seria `"75"` como `string`.

---

## Reto #28 {#sec-sol-array-28}

La respuesta del [Reto #28](#sec-array-28) es:

**C. `7`**

**Explicación:**

`parseInt` convierte un valor a tipo `number` de una base concreta (base binaria, octal, decimal, etc).

En el ejemplo intentamos convertir `"7*6"` a base `10`, osea, a base decimal.

`parseInt` toma los valores validos de izquierda a derecha, dicho esto, solo tomará el valor `7` (el `*` y todo lo que le precede no es un valor valido para `parseInt`).

En conclusión, solo convierte al `7` de `string` a `number`. 

---

## Reto #29 {#sec-sol-array-29}

La respuesta del [Reto #29](#sec-array-29) es:

**C. `[undefined, undefined, undefined]`**

**Explicación:**

El método `map` es propio del paradigma de la programación funcional. Este método siempre retorna una nuevo arreglo.

En el ejemplo puesto que estamos iterando sobre un arreglo de números, la condición evaluerá `true` para cada uno de los elementos del arreglo, pero hay 2 sentencias `return`. JavaScript ignora todo el código que esta después del primer `return` que encuntra. Dicho esto, tendriamos algo así:

```js
[1, 2, 3].map(num => {
  if (typeof num === "number") return;
});
```
Ahora, si bien la condición se evalua a `true`, el `return` no devuelve nada, simplemente hace que el código se salga del `map`.

Cuando no devolvemos nada en `return`, `map` regresa siempre `undefined`.

Al tener 3 elementos en el arreglo, y recordando siempre que `map` regresa un nuevo arreglo, obtenemos como resultado final un arreglo de 3 `undefined`

---

## Reto #30 {#sec-sol-array-30}

La respuesta del [Reto #30](#sec-array-30) es:

**A. `60`, `40`**

**Explicación:**

Las variables declaradas con `let` y `const` tienen un contexto de bloque, esto significa que solo podrán ser accedidas dentro del bloque de llaves donde fueron declaradas, por ejemplo dentro de un bloque `if` o dentro de una función.

Esta premisa se cumple siempre y cuando esten declaradas dentro de un bloque, si una variable esta fuera de todo bloque entonces se dice que es una variable global y por ende puede ser accedida desde cualquier parte del código.

`let x = 10` es una variable global, puesto que no esta encerrada en ningún tipo de bloque.

Dentro del `if` :

```js
console.log(x + y + z);
```
En el bloque del `if` no se tiene acceso a ninguna variable `x`, por lo tanto javascript subirá al siguiente contexto para buscar una variable `x`, al encontrarla recien realiza la suma `x + y + z` que sería `60`.

En el último `console`:

```js
console.log(x + z);
```
La variable `x` esta en el contexto global, por ende accedemos a su valor sin problema alguno.

La variable `z` esta dentro del bloque `if` y no deberiamos poder acceder a ella, pero `z` esta declarada con `var`, esto la convierte en una variable con contexto de función y no de bloque, entonces accedemos a su valor, para poder sumar `x + z` que sería `40`.


---


## Reto #31 {#sec-sol-array-31}

La respuesta del [Reto #31](#sec-array-31) es:

**C. `"9001"`**

**Explicación:**

Cuando una función regresa un arreglo en Javascript es muy usual utilizar la sintaxis de desestructuración para poder acceder a sus elementos por separado. 

En este ejemplo accedemos a la segunda posición del arreglo de la siguiente manera: 

```js
const [, second] = fn()
```

Esto es lo mismo que decir:

```js
const second = fn()[1]
```

Finalmente convertimos el valor de `number` a `string`.

---

## Reto #32 {#sec-sol-array-32}

La respuesta del [Reto #32](#sec-array-32) es:

**C. La primera función tiene hoisting, la segunda no.**

**Explicación:**

Con una función como la primera es posible hacer esto:

```js
console.log(addTraditional(3,5)); //8
function addTraditional(a, b){
  return a + b;
}
```

Podemos llamar a la función antes de su declaración, caracteristica que se denomina **hoisting**.

Con una función de flecha esto no es posible:

```js
console.log(addArrow(3,5)); // ReferenceError: can't access lexical declaration 'addArrow' before initialization 

const addArrow = (a, b) => {
  return a + b;
}
```

_Nota_: Esta es solo una de las diferencias entre ambas funciones. También podemos mencionar como diferencia el contexto de `this` en ambas funciones pero eso lo dejamos para otro reto.

---

## Reto #33 {#sec-sol-array-33}

La respuesta del [Reto #33](#sec-array-33) es:

**D: `"Oh no an error! Hello world!`**

**Explicación:**

La función `greeting` con la palabra reservada `throw` genera una excepción de tipo `string` en el código.

La función `sayHi` consta de una sentencia `try...catch`, recordemos que si no hay ningún tipo de excepción el código ejecuta el bloque `try` pero como si generamos una excepción entonces entramos al bloque `catch` donde el parámetro `e` adopta el valor de la excepción, osea, `Hello world!`. Por eso el resultado es `"Oh no an error! Hello world!"`

---

## Reto #34 {#sec-sol-array-34}

La respuesta del [Reto #34](#sec-array-34) es:

**B. { admin: true, name: "Lydia", age: 21 }**

**Explicación:**

El **spread operator** en este ejemplo se encarga de propagar el objeto `user` dentro del objeto `admin`.

**Sin** usar el `spread operator` tendriamos un objeto anidado:

```js
{ admin: true, { name: "Lydia", age: 21 } }
```

Justamente el **spread operator** se encarga de expandir `user` para evitar el anidamiento.

---

## Reto #35 {#sec-sol-array-35}

La respuesta del [Reto #35](#sec-array-35) es:

**A: `'{"level":19, "health":90}'`**

**Explicación:**

`JSON.stringify` puede recibir un segundo parámetro opcional denominado `replacer`, puede ser una función o un arreglo, y se encarga de hacer un filtro de las propiedades del objeto que deseamos convertir a `string`, en el ejemplo solo deseamos convertir las propiedades `["level", "health"]`, ignorando `username`. 

---

## Reto #36 {#sec-sol-array-36}

La respuesta del [Reto #36](#sec-array-36) es:

**A. `10`, `10`**

**Explicación:**

La primera función en llamarse es `increaseNumber` que solo se encarga de retornar la variable `num` y luego la incrementa; `num` no esta en el scope de la función por eso pasamos a buscar la variable en el scope global. Esta función regresará `10`.

`num1` se pasa como parámetro a `increasePassedNumber` que hace lo mismo que `increaseNumber`, regresa primero el valor de la variable y luego la incrementa, por ello obtenemos nuevamente como salida el valor `10`.

---

## Reto #37 {#sec-sol-array-37}

La respuesta del [Reto #37](#sec-array-37) es:

**C. `20`, `20`, `20`, `40`**

**Explicación:**

Hay que concentrarse en el orden en que se llaman las funciones para comprender que es lo que pasa acá.

**Primera llamada:**
A `multiply` no le pasamos ningún parámetro, por ende, toma el parámetro por defecto `x` que es un objeto desestructurado cuya key `number` tiene el valor de `10`. Entonces `x.number *= 2` nos retorna `20`.

**Segunda llamada:**
Similar a la primera llamada, hacemos lo mismo, entonces obtenemos nuevamente `20`.

**Tercera llamada:**
A `multiply` en su llamada le pasamos el argumento `value` por lo que la función ahora ignora el parámetro por defecto. `number` es nuevamente `10`, por ello el resultado de la multiplicación nuevamente será `20`.

**Cuarta llamada:**
Similar a la tercera llamada, pero el valor de `value` actual es `20` que fue el resultado de la tercera llamada, entonces ahora `x.number *= 2`, será `40`.


---

## Reto #38 {#sec-sol-array-38}

La respuesta del [Reto #38](#sec-array-38) es:

**A. `true`, `true`, `false`**

**Explicación:**

Primero, usamos el constructor `Number` para convertir `2` a `number`, como solo es una conversión de primitivos entonces el resultado es `true`.

Segundo, usamos el constructor `Boolean` para convertir `false` a boleano, nuevamente solo es una conversión, entonces el resultado de la comparación es `true`.

Tercero, ningún `Symbol` es igual a otro `Symbol`, por más que en el ejemplo tengan los mismos placeholders `foo`, nunca serán iguales. Entonces siempre nos dará `false`.

No debemos confundir el contructor `Number` y `Boolean` por sí mismos, con dichos costructures acompañados de la palabra `new`, si hacemos lo siguiente:

```js
const a = new Number(2);
const b = new Boolean(true);
```

Ambas variables serán objetos creados por medio de estos contructores y no solo conversiones como en el ejercicio de este reto.

---

## Reto #39 {#sec-sol-array-39}

La respuesta del [Reto #39](#sec-array-39) es:

**C. `Promise {<pending>}`**

**Explicación:**

Una función asíncrona siempre regresa una **promesa** pero dicha promesa no basta con ser devuelta sino que debe ser consumida, para ello debemos usar las palabras reservadas `then` y `catch`.

Cuando llamamos `getData()` no consumimos la promesa con `then`, solo llamamos a la función por ende no podemos afirmar que la promesa esta en **estado resuelto** o **estado rechazado**, en conclusión inevitablemente la promesa esta en **estado pendiente**.

---

## Reto #40 {#sec-sol-array-40}

La respuesta del [Reto #40](#sec-array-40) es:

**B. `2`**

**Explicación:**

El método `push` regresa la longitud del arreglo. Inicialmente el arreglo `["banana"]` tiene langitud `1`, al hacer el `push` del item `apple` la longitud será de `2` y ojo, no hacemos un `return` de `list` sino de `list.push(item)` por ello regresamos la longitud que es `2`.

Si quisieramos regresar el arreglo resultante completo deberiamos hacer:

```js
function addToList(item, list) {
  list.push(item);
  return list; // ["banana","apple"]
}
```

---