# Soluciones {.unnumbered} 

## Reto #1 {#sec-sol-array-1}

La respuesta del [Reto #1](#sec-array-1) es:

**A. `[1, 33, 9, -2]`**

**Explicación:**

El objeto `Number` de JavaScript puede convertir los los valores de un arreglo a números, pero hay que tener cuidado con tipos `boolean`, `undefined` o `null`.

Este hack es muy útil cuando tenemos un arreglo de strings que queremos convertir a números.

---

## Reto #2 {#sec-sol-array-2}

La respuesta del [Reto #2](#sec-array-2) es:

**D. `Pera`**

**Explicación:**

Para usar la desestructuración en arreglos es importante tener en cuenta los índices de los elementos. Por ello para acceder a `Pera` en el arreglo `fruits` haríamos algo como:

```js
const [, , , pear]  = fruits;
```

Donde cada `,` representa el salto de un índice del arreglo.

Para una sistaxis mas breve podemos usar esto:

```js
const { 3:pear } = fruits;
```

Donde el `3` representa las posiciones que deseamos saltar.

Nota que aunque frutas sea un arreglo usamos `{}` para la desestructuración.

---

## Reto #3 {#sec-sol-array-3}

**Explicación:**

JavaScript tiene una peculiaridad que se denomina **coerción de tipos**. Al intentar realizar algún tipo de operación o comparación ambigua el lenguaje tratará de realizar una conversión de tipos implícita para poder devolver un resultado más o menos lógico, el problema acá radica en que muchas veces el resultado obtenido será diferente al esperado.

Veamos el primer ejemplo:

```js
console.log(false == 0)
```

En JavaScript existen lo que denomina **valores `falsy`** y son los siguientes:

* `0`
* `-0`
* `0n`
* `false`
* `null`
* `undefined`
* `NaN`
* Cualquier tipo de cadena vacía: `'', ""`

Todos estos valores son considerados como falsos para el lenguaje.

Como `0` es un **valor falsy** entonces, aunque no lo veamos, JavaScript hace algo como esto tras bambalinas:

```js
console.log(false == false)
```

Y como estamos usando el operador de comparación débil `==` nos limitamos a comparar los valores **más NO los tipos de datos**.

En conclusión, la respuesta es `true` por **coerción de tipos**

Pasemos al siguiente ejemplo:

```js
console.log(false === 0)
```

Al usar el **operador estricto de comparación** `===` comparamos tanto el **valor** como el **tipo de dato**, `false` es de tipo `boolean` y `0` es de tipo `number` ergo, la respuesta es `false`.

En otras palabras, también es correcto afirmar que al usar el `===` JavaScript no hace **coerciones de tipo**, por ello es ampliamente sugerido usarlo.

--- 

## Reto #4 {#sec-sol-array-4}

**Explicación:**

Si bien `null` y `undefined` son valores `falsy` al momento de que JavaScript haga **coerciones de tipo** pasa algo raro, esto se debe a que tanto `null` como `undefined` sólo son **iguales** a sí mismos y entre ellos:

```js
console.log(null == null); // true
console.log(undefined == undefined); // true
console.log(undefined == null); // true
```

Solo en estos casos obtendremos como salida un `true`.

Pero es recomendable usar siempre el **operador estricto de igualdad** `===`:

```js
console.log(null === null); // true
console.log(undefined === undefined); // true
console.log(undefined === null); // false
```

Esto para evitar que JavaScript haga **coerciones de tipos** y obtengamos resultados no esperados.

--- 

## Reto #5 {#sec-sol-array-5}

**Explicación:**

`NaN` o "Not a Number" es el resultado que nos brinda JavaScript cuando intentamos hacer una operación que no tiene sentido, y por ende el resultado no será un número, por ejemplo:

```js
console.log(Math.sqrt(-1)) // NaN
console.log(10 / "hola") // NaN
console.log(Number("hola")) // NaN
```

Obtener la raiz cuadrada de `-1`, dividir un entero entre una cadena y convertir una cadena a un número son algunas operaciones que nos dan `NaN`.

Ahora bien, cuando intentamos hacer `console.log(NaN === NaN)`, aún usando el operador `===` obtenemos `false` ya que el `NaN` de una operación no puede ser igual al `NaN` de otra. Dos `NaN` nunca serán iguales por este motivo. 

En conclusión, no existe ningún valor en JavaScript que igualado a `NaN` sea `true`, ni siquiera el mismo `NaN`. Esto es una característica propia del lenguaje.

---

## Reto #6 {#sec-sol-array-6}

La respuesta del [Reto #6](#sec-array-6) es:

**A. `Hello`**

**Explicación:**

Cuando aplicamos el operador de asignación `=` entre objetos pensado que así lograremos obtener una copia del mismo estamos cayendo en un **error de novato**.

Recuerda que los objetos se manejan segun su **referencia** y no por su **valor** como lo hacen los tipos primitivos del lenguaje, esto significa que al hacer esto:

```js
let c = { greeting: "Hey!" };
let d;

d = c;
```

No solo estamos copiando los valores del objeto `c` al objeto `d` sino que también copiamos su **referencia en memoria**. Esta referencia es la dirección donde dicho objeto se almacenerá en el disco duro del ordenador; en JavaScript al ser un lenguaje de alto nivel no podemos acceder a dichas direcciones como en lenguajes de bajo nivel como por ejemplo **lenguaje ensamblador** (aunque en Python si se pude con la función `id()` pero este no es un libro de Python).

Dicho en otras palabras, las direcciones de memoria del objeto `c` y del objeto `d` son las mismas, apuntan a la misma dirección, por ello, cuando intentamos modificar el objeto `c`:

```js
c.greeting = "Hello";
```

En realidad, estamos modificando ambos objetos.

Para crear copias de objetos de manera segura se recomienda usar el **spread operator** con su sintaxis de tres puntos `...`

```js
let c = { greeting: "Hey!" };
let d;

d = {...c};

c.greeting = "Hello";
console.log(d.greeting); // Hey!
console.log(c.greeting); // Hello
```

Este método solo sirve para copiar objetos en el primer nivel, si deseamos realizar copias de objetos anidados se puede recurrir a otras alternativas como por ejemplo `JSON.stringify`.

---

## Reto #7 {#sec-sol-array-7}

La respuesta del [Reto #7](#sec-array-7) es:

**A. `1`, `false`**

**Explicación:**

El el primer caso, el operador `+` intenta convertir a `number` al valor `true`, por **coerción de tipos** JavaScript infiere a `true` como 1. 

En el segundo caso, intentamos negar un `string`, dicho `string` es un valor truthy, por ende, nuevamente por **coerción de tipos** JavaScript infiere al `string` "Lydia" como `true`, y la negación de `true` es `false`.

---

## Reto #8 {#sec-sol-array-8}

La respuesta del [Reto #8](#sec-array-8) es:

**C. `true`, `false`, `false`**

**Explicación:**

En el primer `console.log`:

```js
console.log(a == b);
```

Vemos que hacemos una comparación débil con el operador `==`, esto significa que **solo compararemos los valores de `a` y `b`**, por ende obtendremos un `true`.

En el segundo `console.log`:

```js
console.log(a === b);
```

Hacemos una comparación estricta usando el operador `===`, esto significa que compararemos **valores** y **tipos de datos**, `a` y `b` tienen el mismo valor, pero `a` es de tipo `number` y `b` esta siendo inicializada usando el contructor `Number`, por ende es un objeto; entonces obtendremos un `false`.

En el tercer `console.log`

```js
console.log(b === c);
```

Al igual que el caso anterior, intentamos comparar de manera estricta un objeto contra un número, entonces tendremos como resultado un `false`.

**Conclusión: trata de usar simpre `===`**

---

## Reto #9 {#sec-sol-array-9}

La respuesta del [Reto #9](#sec-array-9) es:

**A. `No pasa nada, es totalmente correcto.`**

**Explicación:**

WTF! Cuando vi que hacer esto es posible casi me caigo de la silla. Expliquemos por que:

Oiste o leiste alguna vez esta frase: **"Todo en JavaScript es un objeto"** Dejame decirte que no es mentira, literalmente todo es un objeto, todo lo que no sea un tipo primitivo en JavaScript es un objeto, desde arreglos, los propios objetos claro, las promesas, y también las **funciones**.

En el ejemplo, la función `bark()` funciona completamente bien:

```js
function bark() {
  console.log("Woof!");
}
console.log(bark()) // Woof!
```

Y si intentamos acceder a la propiedad `animal` no tendremos ningún problema:

```js
function bark() {
  return "Woof!"
}

bark.animal = "dog";
console.log(bark.animal); // dog
```
Este es un comportamiento muy jocoso del lenguaje y esta bueno saber que es posible hacer estas cosas aunque no tenga muchos casos de uso.

---

## Reto #10 {#sec-sol-array-10}

La respuesta del [Reto #10](#sec-array-10) es:

**A. `{}`**

**Explicación:**

En la primera línea declaramos `let greeting;`, al declarar una variable con `let` sin inicializarla, esta toma el valor de `undefined`.

En la segunda línea, se comete un error de tipeo `greetign = {};`, pero como la variable no esta declarada ni con `var`, `let` o `const`; Javascript tras bambalinas hace algo como lo siguiente aunque el programador no lo vea:

```js
var greetign = {}; // Typo!
```

Entonces `greetign` se crea como **variable global**, en el navegador en el objeto `window` y en un entorno de Node.js en el objeto `global`.

El código final se veria así:

```js
let greeting; // undefined
var greetign = {}; // Typo!
console.log(greetign); // {}
```

::: {.callout-tip}
## Tip

Siempre declara tus variables con `let` o `const`. Deja que `var` muera y no la uses más.
:::

---

## Reto #11 {#sec-sol-array-11}

La respuesta del [Reto #11](#sec-array-11) es:

**C. `"11111"`, `10`**

**Explicación:**

Vayamos por partes.

En el primer `console.log(x + y)`:
Intentamos sumar las variables `x` y `y`, pero `x` es una cadena y `y` es un número, por **coersión de tipos** la operación ya no será una suma aritmética sino una concatenación de cadenas. Dicho en otras palabras la variable `y` sera convetida implicitamente por el interprete de JavaScript a cadena, por lo que el resultado será `"11111"`.

En el segundo `console.log(y - z)`:
Intentamos restar las variables `y` y `z`, pero `y` es una cadena y `z` es un número, por **coersión de tipos** la operación será una resta artimética de toda la vida. Dicho en otras palabras la variable `z` sera convetida implicitamente por el interprete de JavaScript a número, por lo que el resultado será `10`.

::: {.callout-tip}
## Tip
En JavaScript el operador `+` puede significar una suma o una concatenación según el caso de uso, pero el operador `-` siempre significara una resta artimética.
:::

---

## Reto #12 {#sec-sol-array-12}

La respuesta del [Reto #12](#sec-array-12) es:

**C. `Hmm... You don't have an age I guess`**

**Explicación:**

Cuando comparamos objetos hay que tener mucho cuidado.

Comparar primitivos es sencillo, pero recuerda que los objetos se almacenan en memoria teniendo en cuenta su **referencia** y no su **valor**.

Dicho esto, el objeto que pasamos como argumento a `checkAge` es el objeto `{ age: 18 }`, este es diferente al objeto que evaluamos en los `if` de la función, por más que usemos comparación estricta, seguirán siendo objetos diferentes **por que sus referencias son diferentes**:

```js
{ age: 18 } == { age: 18 } //false
{ age: 18 } === { age: 18 } //false
```

Entonces nunca se cumple ni la condición del `if` ni del `else if` y se ejecuta el `else` directamente, imprimiendo `Hmm... You don't have an age I guess` como resultado final.

---

## Reto #13 {#sec-sol-array-13}

La respuesta del [Reto #13](#sec-array-13) es:

**C. `object`**

**Explicación:**

Cuando usamos la sintaxis de `...` en los parámetros de una función (REST parameter desde ES6) convertimos a dicho parámetro en un arreglo. Entonces es tentador marcar la opción **B. `"array"`** pero esto sería un **error de novato**. En JavaScript no existe el tipo de dato `array`, para **tipos no primitivos** el lenguaje los evalua como `object`. Por ese motivo la respuesta correcta es la opción **C. `object`**.

---

## Reto #14 {#sec-sol-array-14}

La respuesta del [Reto #14](#sec-array-14) es:

**D. `string`**

**Explicación:**

El operador `+` por lo general intentará realizar una concateneción, en este caso, el interprete de JavaScript, por **coerción de tipos** intentará convertir los arreglos a cadenas de texto, haciendo algo como esto aunque no lo veamos:

```js
console.log(typeof ([].toString() + [].toString())); 
console.log(typeof ("" + ""));
console.log(typeof ("")); //string
```

---

## Reto #15 {#sec-sol-array-15}

La respuesta del [Reto #15](#sec-array-15) es:

**C: `true`, `true`, `false`, `true`**

**Explicación:**

En el objeto:

```js
const obj = { 1: "a", 2: "b", 3: "c" };
obj.hasOwnProperty("1"); //true
obj.hasOwnProperty(1); //true
```

El método `hasOwnProperty` propio de los objetos retorna un `boolean` dependiendo **si la key del objeto existe o no**.

Lo que hay que tener en cuenta es que las claves de un objeto siempre son de tipo `string` aunque no lo especifiquemos.

En el `set`:

```js
const set = new Set([1, 2, 3, 4, 5]);
set.has("1"); //false
set.has(1); //true
```

Esto no funciona como en un objeto, recuerda que un `set` es como un tipo de arreglo de valores no repetidos. Por ello `1` `string` no concuerda con `1` `number`.

---

## Reto #16 {#sec-sol-array-16}

La respuesta del [Reto #16](#sec-array-16) es:

**C: `{ a: "three", b: "two" }`**

**Explicación:**

Cuando en un objeto tenemos keys repetidas, estas se sobre escriben respetando el orden alfabético. Por ello la respuesta es C.

---

## Reto #17 {#sec-sol-array-17}

La respuesta del [Reto #17](#sec-array-17) es:

**A. "Just give Lydia pizza already!"**

**Explicación:**

`String` es el contructor que tiene JavaScript para gestionar las cadenas de texto. En el ejemplo se agrega la función `giveLydiaPizza` al prototipo de las cadenas, con ello, esta función estará disponible para todas las cadenas.

Si intentamos hacer algo como lo siguiente:

```js
String.prototype.giveLydiaPizza = () => {
  return "Just give Lydia pizza already!";
};

const bool = true;
console.log(bool.giveLydiaPizza()); 
//TypeError: bool.giveLydiaPizza is not a function 
```

Obtendremos un error, `giveLydiaPizza` solo se puede usar con un `string`. 

---

## Reto #18 {#sec-sol-array-18}

La respuesta del [Reto #18](#sec-array-18) es:

**B. `First`, `Third`, `Second`**

**Explicación:**

Para comprender la respuesta es necesario entender temas estructurales del lenjuage, es decir, ir a las bases de JavaScript y conocer conceptos como **Event Loop**, **Call Stack**, **Task Queue**, **Web API's** entre otros. 

Para poder darse cuenta, el secreto que puedo compartirte es concentrarse en el orden de las llamadas a las funciones, es decir en estas líneas:

```js
bar(); // primero llamamos a bar()
foo(); // luego a foo()
baz(); // finalmente baz()
```

Primero, llamamos a la función `bar()` que tiene en su cuerpo un `setTimeout` puedes pensar que al carecer de delay en ms este código se ejecuta de inmediato, pero no es así, ya que `setTimeout` es una `Web API`, por este motivo este código debe almacenarse en lo que llamamos **Task Queue**.

Segundo, llamamos a la función `foo()`, que contiene código síncrono, por ende pasa directamente al **Call Stack** y mostramos por consola `First`.

Tercero, llamamos a la función `baz()`, que contiene código síncrono nuevamente, por ello pasa al **Call Stack** y mostramos por consola `Third`.

Ahora, el algotirmo del **Even Loop** se da cuenta que no hay mas funciones por llamar, y verifica que el **Call Stack** esta vacio, entonces busca si hay algo en el **Task Queue**, y oh sorpresa, esta nuestro `setTimeout`, entonces lo pasa al **Call Stack** para finalmente mostrar por consola `Second`

Es complicado de entender al principio, te dejo una [demostración gráfica](https://www.jsv9000.app/?code=Y29uc3QgZm9vID0gKCkgPT4gY29uc29sZS5sb2coIkZpcnN0Iik7CmNvbnN0IGJhciA9ICgpID0%2BIHNldFRpbWVvdXQoKCkgPT4gY29uc29sZS5sb2coIlNlY29uZCIpKTsKY29uc3QgYmF6ID0gKCkgPT4gY29uc29sZS5sb2coIlRoaXJkIik7CgpiYXIoKTsKZm9vKCk7CmJheigpOw%3D%3D) 

---

## Reto #19 {#sec-sol-array-19}

La respuesta del [Reto #19](#sec-array-19) es:

**B. `string`**

**Explicación:**

Esta pregunta es un poco trampa. Pero la respuesta es chistosa:

`typeof 1` regresa `"number"`, literalemnte la cadena `"number"`, entonces tendriamos `typeof "number"` y esto da obiamente `string`. 

---

## Reto #20 {#sec-sol-array-20}

La respuesta del [Reto #20](#sec-array-20) es:

**C. `[1, 2, 3, 7 x empty, 11]`**

**Explicación:**

JavaScript no arroja ningún error, crea valores `undefined` hasta completar los índices pertinentes, luego muestra el último valor creado, en este caso `11`.

Dependiendo en que entorno de ejecución se ejecute el código puede variar un poco la salida, una respuesta valida también sería:

```js
[1, 2, 3, undefined, undefined, undefined, undefined, 
undefined, undefined, undefined, 11]
```
---

## Reto #21 {#sec-sol-array-21}

La respuesta del [Reto #21](#sec-array-21) es:

**C. `[1, 2, 0, 1, 2, 3]`**

**Explicación:**

`acc` se inicializa con `[1, 2]`. En el `return` de la función concatenamos este valor de inicialización con el arreglo anidado, arreglo por arreglo.

---

## Reto #22 {#sec-sol-array-22}

La respuesta del [Reto #22](#sec-array-22) es:

**B. `false`, `false`, `true`**

**Explicación:**

El operador `!!` realiza una doble negación.

En el primer caso, por **coerción de tipos**, `null` es un valor **falsy**, si lo negamos 2 veces, tendríamos `false`.

En el segundo caso, por **coerción de tipos**, `""` es un valor **falsy**, si lo negamos 2 veces tendríamos `false`.

Por último, el tercer caso, y nuevamente por **coerción de tipos**, el valor `1` es un valor `truthy`, si lo negamos 2 veces, obtendremos `true`.

Dicho de otra manera, el operador de doble negación realiza una conversión de tipo a booleano, es decir, transforma cualquier valor en su equivalente booleano.

---

## Reto #23 {#sec-sol-array-23}

La respuesta del [Reto #23](#sec-array-23) es:

**C. `Hi cada segundo`**

**Explicación:**

La función `setInterval` es una `Web API` que recibe un intervalo en milisegundos, e imprime el cuerpo de la función en dicho intervalo.

---

## Reto #24 {#sec-sol-array-24}

La respuesta del [Reto #24](#sec-array-24) es:

**A. `["O", "s", "c", "a", "r"]`**

**Explicación:**

Un `string` es un elemento iterable en JavaScript, por ende es posible usar el `spread operator` directamente obteniendo la propagación de la cadena letra por letra.

---

## Reto #25 {#sec-sol-array-25}

La respuesta del [Reto #25](#sec-array-25) es:

**D. `[{ name: "Carmen" }]`**

**Explicación:**

Cuando hacemos:

```js
const members = [person];
```

En realidad estamos realizando una copia a la referencia de `person`, tanto `person` como `members` apuntan a la misma referencia del objeto en memoria.

Por este motivo al hacer:

```js
person = null;
```

Cambiamos el valor de `person` a `null` pero `members` conserva la referencia al objeto y por ello también su valor.

---

## Reto #26 {#sec-sol-array-26}

La respuesta del [Reto #26](#sec-array-26) es:

**B. `"name"`, `"age"`**

**Explicación:**

El bucle `for...in` en JavaScript aplicado sobre un objeto nos brinda las llaves del objeto per se. Recuerda que aunque no lo veamos el lenguaje interpreta las llaves de los objetos como un `string` a no ser que dichas llaves sean de tipo `symbol`. 

Si vemos esto:

```js
const person = {
  name: "Carla",
  age: 26
};
```

JavaScript verá esto:

```js
const person = {
  "name": "Carla",
  "age": 26
};

```
Es por este motivo que cuando ejecutamos: 

```js
for (const item in person) {
  console.log(item);
}
```

La variable `item` tendrá el valor de cada llave del objeto en cada iteración; en el ejemplo al tener solo 2 llaves, entonces `item` valdrá `name` y luego `age`.

---

## Reto #27 {#sec-sol-array-27}

La respuesta del [Reto #27](#sec-array-27) es:

**B. `"75"`**

**Explicación:**

El código JavaScript se ejecuta de arriba hacia abajo y de izquierda a derecha.

Primero realizamos la suma `3 + 4`, puesto que ambos son  de tipo `number` obtenemos `7`.

Ahora tenemos `7 + "5"`, como `"5"` es de tipo `string`, ahora realizamos una concatenación de valores y por `coerción de tipos` el resultado final es `"75"` como `string`.

---

## Reto #28 {#sec-sol-array-28}

La respuesta del [Reto #28](#sec-array-28) es:

**C. `7`**

**Explicación:**

`parseInt` convierte un valor a tipo `number` de una base concreta (base binaria, octal, decimal, etc).

En el ejemplo intentamos convertir `"7*6"` a base `10`, osea, a base decimal.

`parseInt` toma los valores validos de izquierda a derecha, dicho esto, solo tomará el valor `7` (el `*` y todo lo que le precede no es un valor valido para `parseInt`).

En conclusión, solo convierte al `7` de `string` a `number`. 

---

## Reto #29 {#sec-sol-array-29}

La respuesta del [Reto #29](#sec-array-29) es:

**C. `[undefined, undefined, undefined]`**

**Explicación:**

El método `map` es propio del paradigma de la programación funcional. Este método siempre retorna una nuevo arreglo de longitud igual al arreglo original.

En el ejemplo, puesto que estamos iterando sobre un arreglo de números, la condición evaluará `true` para cada uno de los elementos del arreglo, pero hay 2 sentencias `return`. JavaScript ignora todo el código que esta después del primer `return` que encuntra. Dicho esto, tenemos algo así:

```js
[1, 2, 3].map(num => {
  if (typeof num === "number") return;
});
```
Ahora, si bien la condición se evalua a `true`, el `return` no devuelve nada, simplemente hace que el código se salga del `map`.

Cuando no devolvemos nada en la sentencia `return`, `map` regresa siempre `undefined`.

Al tener 3 elementos en el arreglo, y recordando siempre que `map` regresa un nuevo arreglo, obtenemos como resultado final un arreglo de 3 `undefined`.

---

## Reto #30 {#sec-sol-array-30}

La respuesta del [Reto #30](#sec-array-30) es:

**A. `60`, `40`**

**Explicación:**

Las variables declaradas con `let` y `const` tienen un contexto de bloque, esto significa que solo podrán ser accedidas dentro del bloque de llaves donde fueron declaradas, por ejemplo dentro de un bloque `if` o dentro de una función.

Esta premisa se cumple siempre y cuando esten declaradas dentro de un bloque, si una variable esta fuera de todo bloque entonces se dice que es una variable global y por ende puede ser accedida desde cualquier parte del código.

`let x = 10` es una variable global, puesto que no esta encerrada en ningún tipo de bloque.

Dentro del `if` :

```js
console.log(x + y + z);
```
En el bloque del `if` no se tiene acceso a ninguna variable `x`, por lo tanto JavaScript subirá al siguiente contexto para buscar una variable `x`, al encontrarla recien realiza la suma `x + y + z` que sería `60`.

En el último `console`:

```js
console.log(x + z);
```
La variable `x` esta en el contexto global, por ende accedemos a su valor sin problema alguno.

La variable `z` esta dentro del bloque `if` y no deberiamos poder acceder a ella, pero `z` esta declarada con `var`, esto la convierte en una variable con **contexto de función** y no de bloque, entonces accedemos a su valor, para poder sumar `x + z` que sería `40`.

---

## Reto #31 {#sec-sol-array-31}

La respuesta del [Reto #31](#sec-array-31) es:

**C. `"9001"`**

**Explicación:**

Cuando una función regresa un arreglo en Javascript es muy usual utilizar la sintaxis de desestructuración para poder acceder a sus elementos por separado. 

En este ejemplo accedemos a la segunda posición del arreglo de la siguiente manera: 

```js
const [, second] = fn()
```

Esto es lo mismo que decir:

```js
const second = fn()[1]
```

Finalmente convertimos el valor de `number` a `string`.

---

## Reto #32 {#sec-sol-array-32}

La respuesta del [Reto #32](#sec-array-32) es:

**C. La primera función tiene hoisting, la segunda no.**

**Explicación:**

Con una función como la primera es posible hacer esto:

```js
console.log(addTraditional(3,5)); //8
function addTraditional(a, b){
  return a + b;
}
```

Podemos llamar a la función antes de su declaración, caracteristica que se denomina **hoisting**.

Con una función de flecha esto no es posible:

```js
// ReferenceError: can't access lexical declaration 
// 'addArrow' before initialization 
console.log(addArrow(3,5)); 

const addArrow = (a, b) => {
  return a + b;
}
```

_Nota_: Esta es solo una de las diferencias entre ambas funciones. También podemos mencionar como diferencia el contexto de `this` en ambas funciones pero eso lo dejamos para otro reto.

---

## Reto #33 {#sec-sol-array-33}

La respuesta del [Reto #33](#sec-array-33) es:

**D: `"Oh no an error! Hello world!`**

**Explicación:**

La función `greeting` con la palabra reservada `throw` genera una excepción de tipo `string` en el código.

La función `sayHi` consta de una sentencia `try...catch`, recordemos que si no hay ningún tipo de excepción el código ejecuta el bloque `try` pero como si generamos una excepción entonces entramos al bloque `catch` donde el parámetro `e` adopta el valor de la excepción, osea, `Hello world!`. Por eso el resultado es `"Oh no an error! Hello world!"`

---

## Reto #34 {#sec-sol-array-34}

La respuesta del [Reto #34](#sec-array-34) es:

**B. { admin: true, name: "Hernan", age: 21 }**

**Explicación:**

El **spread operator** en este ejemplo se encarga de propagar el objeto `user` dentro del objeto `admin`.

**Sin** usar el `spread operator` tendriamos un objeto anidado:

```js
{ admin: true, { name: "Hernan", age: 21 } }
```

Justamente el **spread operator** se encarga de expandir `user` para evitar el anidamiento.

---

## Reto #35 {#sec-sol-array-35}

La respuesta del [Reto #35](#sec-array-35) es:

**A: `'{"level":19, "health":90}'`**

**Explicación:**

`JSON.stringify` puede recibir un segundo parámetro opcional denominado `replacer`, puede ser una función o un arreglo, y se encarga de hacer un filtro de las propiedades del objeto que deseamos convertir a `string`, en el ejemplo solo deseamos convertir las propiedades `["level", "health"]`, ignorando `username`. 

---

## Reto #36 {#sec-sol-array-36}

La respuesta del [Reto #36](#sec-array-36) es:

**A. `10`, `10`**

**Explicación:**

La primera función en llamarse es `increaseNumber` que solo se encarga de retornar la variable `num` y luego la incrementa; `num` no esta en el scope de la función por eso pasamos a buscar la variable en el scope global. Esta función regresará `10`.

`num1` se pasa como parámetro a `increasePassedNumber` que hace lo mismo que `increaseNumber`, regresa primero el valor de la variable y luego la incrementa, por ello obtenemos nuevamente como salida el valor `10`.

---

## Reto #37 {#sec-sol-array-37}

La respuesta del [Reto #37](#sec-array-37) es:

**C. `20`, `20`, `20`, `40`**

**Explicación:**

Hay que concentrarse en el orden en que se llaman las funciones para comprender que es lo que pasa acá.

**Primera llamada:**
A `multiply` no le pasamos ningún parámetro, por ende, toma el parámetro por defecto `x` que es un objeto desestructurado cuya key `number` tiene el valor de `10`. Entonces `x.number *= 2` nos retorna `20`.

**Segunda llamada:**
Similar a la primera llamada, hacemos lo mismo, entonces obtenemos nuevamente `20`.

**Tercera llamada:**
A `multiply` en su llamada le pasamos el argumento `value` por lo que la función ahora ignora el parámetro por defecto. `number` es nuevamente `10`, por ello el resultado de la multiplicación nuevamente será `20`.

**Cuarta llamada:**
Similar a la tercera llamada, pero el valor de `value` actual es `20` que fue el resultado de la tercera llamada, entonces ahora `x.number *= 2`, será `40`.


---

## Reto #38 {#sec-sol-array-38}

La respuesta del [Reto #38](#sec-array-38) es:

**A. `true`, `true`, `false`**

**Explicación:**

Primero, usamos el constructor `Number` para convertir `2` a `number`, como solo es una conversión de primitivos entonces el resultado es `true`.

Segundo, usamos el constructor `Boolean` para convertir `false` a boleano, nuevamente solo es una conversión, entonces el resultado de la comparación es `true`.

Tercero, ningún `Symbol` es igual a otro `Symbol`, por más que en el ejemplo tengan los mismos placeholders `foo`, nunca serán iguales. Entonces siempre nos dará `false`.

No debemos confundir el contructor `Number` y `Boolean` por sí mismos, con dichos costructores acompañados de la palabra `new`, si hacemos lo siguiente:

```js
const a = new Number(2);
const b = new Boolean(true);
```

Ambas variables serán objetos creados por medio de estos contructores y no solo conversiones como en este reto.

---

## Reto #39 {#sec-sol-array-39}

La respuesta del [Reto #39](#sec-array-39) es:

**C. `Promise {<pending>}`**

**Explicación:**

Una función asíncrona siempre regresa una **promesa** pero dicha promesa no basta con ser devuelta sino que debe ser consumida, una posible solución es usar las palabras reservadas `then` y `catch`.

Cuando llamamos `getData()` no consumimos la promesa con `then`, solo llamamos a la función por ende no podemos afirmar que la promesa esta en **estado resuelto** o **estado rechazado**, en conclusión inevitablemente la promesa esta en **estado pendiente**.

---

## Reto #40 {#sec-sol-array-40}

La respuesta del [Reto #40](#sec-array-40) es:

**B. `2`**

**Explicación:**

El método `push` regresa la longitud del arreglo. Inicialmente el arreglo `["banana"]` tiene langitud `1`, al hacer el `push` del item `apple` la longitud será de `2` y ojo, no hacemos un `return` de `list` sino de `list.push(item)` por ello regresamos la longitud que es `2`.

Si quisieramos regresar el arreglo resultante completo deberiamos hacer:

```js
function addToList(item, list) {
  list.push(item);
  return list; // ["banana","apple"]
}
```

---

## Reto #41 {#sec-sol-array-41}

La respuesta del [Reto #41](#sec-array-41) es:

**A. `0 1 2` y `"Radiohead" "Coldplay" "Nirvana"`**

**Explicación:**

Con el bucle _for...in_, podemos iterar sobre propiedades **enumerables**. Los enumerables en el arreglo son justamente sus índices. Por ello el resultado es `0` `1` `2`.

Con un bucle _for...of_, podemos recorrer sobre **iterables**. Un arreglo por definición es un iterable, en cada iteración la variable `item` es igual al elemento sobre el cual se itera en ese momento. Por ello el resultado es `"Radiohead"` `"Coldplay"` `"Nirvana"`.

En la practica los bucles _for...of_ son más usados y usualmente en raras ocaciones se ven bucles _for...in_.

---

## Reto #42 {#sec-sol-array-42}

La respuesta del [Reto #42](#sec-array-42) es:

**C. `[3, 2, 0.5]`**

**Explicación:**

Los arreglos en JavaScript pueden soportar cualquier tipo de dato incluyendo expresiones a ser evaluadas, por ello todas las operaciones aritméticas se resuelven y acomodan en los índices correspondientes del arreglo.

---

## Reto #43 {#sec-sol-array-43}

La respuesta del [Reto #43](#sec-array-43) es:

**B. `Hi there, undefined`**

**Explicación:**

En JavaScript los parámetros tienen por defecto el valor `undefined`, esto quiere decir que sino pasamos ningún parámetro a una función que los necesite tendremos `undefined`.

---

## Reto #44 {#sec-sol-array-44}

La respuesta del [Reto #44](#sec-array-44) es:

**A. `"C"`**

**Explicación:**

Al llamar a `getStatus` debemos tener el cuenta el scope de las variables, recuerda que tanto `let` como `const` tienen scope de bloque, por ende buscara una variable `status` dentro del bloque de `data` y regresara la cadena `"C"`.

---

## Reto #45 {#sec-sol-array-45}

La respuesta del [Reto #45](#sec-array-45) es:

**C. `ReferenceError`**

**Explicación:**

`const` tiene scope de bloque para las variables, cuando intentamos hacer `return message` la variable `message` no puede ser accedida. Tanto `message` en el bloque `if` como en el `else` son variables diferentes por que estan en bloques diferentes pese a que se llaman igual. Como no es posible acceder a la variable la respuesta es `ReferenceError`.

---

## Reto #46 {#sec-sol-array-46}

La respuesta del [Reto #46](#sec-array-46) es:

**B. `"I"`**

**Explicación:**

Las cadenas de texto en JavaScript son iterables, por ello, al igual que con los arreglos es posible acceder a sus caracteres individuales con la notación de corchetes.

---

## Reto #47 {#sec-sol-array-47}

La respuesta del [Reto #47](#sec-array-47) es:

**B. `20`**

**Explicación:**

Desde ES6 es posible usar parámetros por defecto (siempre y cuando sean los últimos declarados en la función).

En este caso el parámetro por defecto `num1` es el mismo que el primer parámetro, no hay ningun problema simpre y cuando este declarado al final de la lista de parámetros de la función.

Pasamos el argumento `10` a la función `sum`, esto significa que `num2` deberá usar su valor por defecto que seria el mismo de `num1`, osea `10`; entonces `10 + 10` nos da el resultado final `20`.

---

## Reto #48 {#sec-sol-array-48}

La respuesta del [Reto #48](#sec-array-48) es:

**D. `TypeError: newList.push is not a function`**

**Explicación:**

El método `push` regresa la longitud de un arreglo y no el arreglo en si mismo, podemos ver este comportamiento si hacemos lo siguiente:

```js
let newList = [1, 2, 3].push(4)
console.log(typeof newList); // number
```

Después de aplicar por primera vez el método `push`, `newList` ahora ya no es un arreglo, sino un primitivo de tipo `number` entonces cuando intentamos aplicar `push` por segunda vez tratamos de implementar un método propio de los arreglos a una variable de tipo `number`, es justo aqui donde salta el error.

---

## Reto #49 {#sec-sol-array-49}

La respuesta del [Reto #49](#sec-array-49) es:

**A. `name Robert` y `age 30`**

**Explicación:**

El método `entries` del constructor `Object` regresa un arreglo anidado donde cada sub arreglo corresponde a la llave y valor del objeto:

```js
[ [ 'name', 'Robert' ], [ 'age', 30 ] ]
```

Con el bucle `for...of` iteramos sobre el objeto desestructurando los valores con la sintaxis `[x, y]`.

El primer sub arreglo es `[ "name", "Robert" ]` donde `x` toma el valor `name` y `y` toma el valor `Robert`.

El segundo arreglo es `[ 'age', 30 ]` donde `x` toma el valor `age` y `y` toma el valor `30`.

---

## Reto #50 {#sec-sol-array-50}

La respuesta del [Reto #50](#sec-array-50) es:

**D. `SyntaxError`**

**Explicación:**

Cuando vemos en la lista de parámetros de una función la sintaxis de tres puntos `...` nos referimos a lo que se denomina un **paramétro de tipo REST**. En el cuerpo de la función este tipo de parámetro se trata como un arreglo pero siempre debe estar declarado al final de la lista de parámetros, caso contrario tendremos un error de sintaxis.

Si volvemos a escribir la función pero esta vez teniendo en cuenta lo anterior dicho:

```js
function getItems(fruitList, favoriteFruit, ...args) {
  return [...fruitList, ...args, favoriteFruit]
}

console.log(getItems(["banana", "apple"], "pear", "orange"))
```
Obtemos por consola: `["banana", "apple", "orange", "pear"]`

---


## Reto #51 {#sec-sol-array-51}

La respuesta del [Reto #51](#sec-array-51) es:

**B. `a is bigger`, `undefined` y `b is bigger`, `undefined`**

**Explicación:**

Después de una expresión JavaScript pone automáticamente un punto y coma para indicar al interprete que dicha expresión finalizo en una línea de código en concreto. Esto se denomina **Insercción automática de punto y coma**.

Al llegar al `return` el programador ve esto:

```js
  return 
  a + b
```

Pero el interprete reconoce la palabra `return` con el fin de una expresión, por lo tanto, aunque no lo veas, JavaScript hará esto:

```js
  return;
  a + b; // jamás llegamos a ejecutar esta línea
```

Y ya sabemos que en una función al encontrar la palabra `return` todo el código posterior que pueda haber no se ejecuta, ni si quiera se evalua, entonces jamás se llegara a hacer la operación `a + b`.

Cuando una función no retorna nada explicitamente, javascript hace que el `return` arroje un `undefined` de manera implicita.

---

## Reto #52 {#sec-sol-array-52}

La respuesta del [Reto #52](#sec-array-52) es:

**D. `{Symbol('a'): 'b'}` y `[]`**

**Explicación:**

Una variable de tipo `Symbol` cumple con 3 características principales:

* No es un elemento enumerable.
* Permite representar valores completamente únicos en el código, útil para crear llaves de objetos y evitar colisiones.
* Podemos crear propiedades "ocultas" en objetos.

El primer `console.log` imprime el objeto en su totalidad, incluyendo los valores no enumerables, por ello podemos ver la `key` de tipo `Symbol` y su valor un `string` con valor `b`.

Al intentar obtener las `keys` del objeto con `Object.keys` obtendremos un arreglo vacío justamente por que el `Symbol` no es un elemento que se pueda enumerar, de esta manera es posible "ocultar" ciertas propiedades de un objeto.

---

## Reto #53 {#sec-sol-array-53}

La respuesta del [Reto #53](#sec-array-53) es:

**A. `[1, [2, 3, 4]]` y `SyntaxError`**

**Explicación:**

* En la función `getList`:

Tenemos una desestructuración de arreglos en la lista de parámetros de la función y además `y` es un parámetro de tipo REST. 

Por ende, al pasar el argumento `list`, `x` será igual al primer elemento del arreglo, ósea, `1`. `y` como es de tipo REST será un arreglo con todos los elementos restantes de `list`, ósea, `[2, 3, 4]`.
La función regresa un nuevo arreglo `[x, y]`, entonces tendríamos un arreglo anidado y como resultado `[1, [2, 3, 4]]`

* En la función `getUser`:

Recibe un único parámetro `user` que es un objeto y luego lo regresa. 

Las funciones de tipo flecha tiene la característica denominada **return implícito** con esto se logra escribir funciones más compactas y de una sola línea, pero cuando intentamos usar un **return implícito** para devolver un objeto es **obligatorio** usar paréntesis para envolver al objeto en cuestión, sino hacemos esto el interprete nos arrojará un `SyntaxError`.

Para que el **return implícito** tenga sentido tendríamos que usar paréntesis para envolver el objeto:

```js
const getUser = user => ({ name: user.name, age: user.age })
const user = { name: "Messi", age: 40 }
console.log(getUser(user)); // {name: "Messi", age: 40}
```

---

## Reto #54 {#sec-sol-array-54}

La respuesta del [Reto #54](#sec-array-54) es:

**C. `TypeError`**

**Explicación:**

`name` no es ni hace referencia a una función, no tiene sentido intentar invocar a un `string` como si fuera una función. 

No pude ser un `SyntaxError` porque no se cometio ningún error de tipeo, el código no esta mal escrito pero tampoco es un código valido.

No puede ser `ReferenceError` porque no hay problemas de referencia al intentar acceder a la variable `name`.

Se genera una excepción de tipo `TypeError` cuando un valor no es del tipo esperado, entonces se lanza un `TypeError: name is not a function!`

---

## Reto #55 {#sec-sol-array-55}

La respuesta del [Reto #55](#sec-array-55) es:

**B. `Impossible! You should see a therapist after so much JavaScript lol`**

**Explicación:**

Muchas cosas que analizar en este ejemplo.

La sintaxis de backticks, comillas simples invertidas o comillas francesas (alt+96) sirven para evaluar expresiones dentro de cadenas de texto.

**Primera expresión a evaluar:** 

En `${[] && 'Im'}` tenemos el operador de **corto circuito** `&&`. 

Para usar los operadores de corto circuito debemos tener en cuanta los valores `truthy` y `falsy`. 

Si la primera parte de la expresión evalua como `truthy` entonces ejecutamos la segunda parte de la expresión. 

Los valores `truthy` son:

* `true`
* `{}`
* `[]`
* Cualquier valor de tipo `number` (`42`, `-56`, `1.5`, `-6.33`)
* Cualquier `string` que no sea vacio (`"0"`, `"Hola mundo"`, `"false"`)
* El objeto `Date` (`new Date()`)

Volviendo al ejemplo, un arreglo vacio `[]` es `truthy` entonces se ejecuta la segunda parte de la expresion, osea, el `string` `'Im'`.

**Segunda expresión a evaluar:** 

En `${ '' && `n't`}` nuevamente tenemos el **operador de corto circuito** `&&`, esta vez la primera parte de la expresión es un valor `falsy`.

Los valores `falsy` son:

* `false`
* `0`
* `""` (cualquier cadena vacía)
* `undefined`
* `null`
* `NaN`

La primera parte de la expresión es una cadena vacia que vendría a representar un valor `falsy` y por ello la segunda parte de la expresión `n't` no se ejecuta.

En conclusión, la respuesta es: `Impossible! You should see a therapist after so much JavaScript lol`

---

## Reto #56 {#sec-sol-array-56}

La respuesta del [Reto #56](#sec-array-56) es:

**C. `{}` `""` `[]`**

**Explicación:**

En JavaScript el código se lee de arriba hacia abajo y de izquierda a derecha.

* **Para la variable `one`**:

`false || {} || null`

Primero evaluamos `false || {}` y obtenemos `{}`.

Entonces nos queda `{} || null` y como las llaves vacias es un valor `truthy` entonces el `null` no se evalua dando como resultado `{}`.

* **Para la variable `two`**:

`null || false || ""`

Primero evaluamos `null || false`, `null` es `falsy` entonces si ejecutamos `false`.

Entonces nos queda `false || ""`, y obtenemos como resultado la cadena vacia `""`

* **Para la variable `three`**:

`[] || 0 || true`

Primero evaluamos `[] || 0`, el arreglo vacio es un valor `truthy` por lo que `0` no se ejecuta.

Entonces nos queda `[] || true`, nuevamente el arreglo vacio es `truthy` y esta vez es `true` quien no se llega a ejecutar, entonces el resultado es `[]`.

---

## Reto #57 {#sec-sol-array-57}

La respuesta del [Reto #57](#sec-array-57) es:

**D. `second`, `I have resolved!` y `I have resolved!`, `second`**

**Explicación:**

`firstFunction` es una función simple que llama a `myPromise` usando el método `then` propio de las promesas. Por **Event Loop** las promesas pasan al **Task Queue** entonces primero ejecutamos el `console.log` y mostramos `second` por consola, ahora el **Call Stack** esta vacio y la promesa que estaba en la **Task Queue** pasa al **Call Stack** y resolvemos la promesa mostrando `'I have resolved!'`.


`secondFunction` es una función asíncrona, al llamar a `myPromise` con `await` esperamos el tiempo necesario para que la promesa se ejecute, entonces mostramos primero por consola `'I have resolved!'` y luego `second`.

Cuando tenemos sintaxis `async await` escribimos código de manera síncrona pero se ejecuta de manera asíncrona.  

---

## Reto #58 {#sec-sol-array-58}

La respuesta del [Reto #58](#sec-array-58) es:

**C. `3`, `Lydia2`, `[Object object]2`**

**Explicación:**

A cada `item` de la variable `set` aplicamos el operador `+` con el número `2`.

Para `1` que es `number` realizamos una suma simple obteniendo como resultado `3`.

Para la cadena `Cris` y por **coerción de tipos** convertimos al número `2` en `string` y realizamos una concatenación obteniendo `Cris2`.

Para el objeto `{ name: "Cris" }` nuevemente por **coerción de tipos** convertimos tanto al objeto y al número `2` a `string` obteniendo `[Object object]2`.

Recuerda que en JavaScript el operador `+` puede ser usado para sumar números y para concatenar cadenas de texto.

---

## Reto #59 {#sec-sol-array-59}

La respuesta del [Reto #59](#sec-array-59) es:

**B. `They are the same!`**

**Explicación:**

Tanto el parámetro `person1` como `person2` adoptará el valor de `person`, osea el objeto `{ name: "Allan" }`.

Los objetos se pasan por referencia. En el ejemplo, `person1` y `person2` apuntan a la misma dirección de memoria entonces la condición del `if` no se cumple y pasamos a imprimir `They are the same!`.

---

## Reto #60 {#sec-sol-array-60}

La respuesta del [Reto #60](#sec-array-60) es:

**D. `TypeError`**

**Explicación:**

En JavaScript existen 2 maneras de acceder a las propiedades de los objetos, por notación del punto o por notación de corchetes.

Cuando hacemos `colorConfig.colors[1]` literalmente estamos buscando una propiedad `colors` en el objeto `colorConfig` y como no existe esta propiedad entonces obtenemos un `undefiend`, entonces ahora JavaScript intentará hacer `undefined[1]` y esto no es un código valido, por ello la consola muestra un `TypeError`.

Cuando queremos usar variables para hacer lo que se denomina **acceso a propiedades dinámicas de objetos** necesitamos usar la notación de corchetes: `colorConfig[colors[1]]` que nos devolverá `true`, el valor de la propiedad `red` del objeto `colorConfig`.

---

## Reto #61 {#sec-sol-array-61}

La respuesta del [Reto #61](#sec-array-61) es:

**D. `splice`**

**Explicación:**

`splice` es un método mutable de arreglos capaz de agregar, eliminar o reemplazar los elementos del mismo.

El resto de los métodos son usados mucho en programación funcional y por ende son **inmutables**.

---

## Reto #62 {#sec-sol-array-62}

La respuesta del [Reto #62](#sec-array-62) es:

**A. `['pizza', 'chocolat', 'avocat', 'egg']`**

**Explicación:**

Tenemos un arreglo `food` y un objeto `info` independiente uno del otro.

`info` solo tiene la propiedad `favoriteFood` que apunta al índice `0` del arreglo `food`, por lo tanto `info` seria igual a:

```js
const info = { favoriteFood:'pizza'}
```

Posteriormente "pisamos" o sobre escribimos este valor modifiando `'pizza'` por `'apple'`.

```js
info.favoriteFood = 'apple'
```

Ahora `info` se ve así:

```js
const info = { favoriteFood:'apple'}
```

En ningún momento modificamos de ninguna manera el array `food`, por ende sigue siendo el mismo: `['pizza', 'chocolat', 'avocat', 'egg']`


---

## Reto #63 {#sec-sol-array-63}

La respuesta del [Reto #63](#sec-array-63) es:

**D. `ReferenceError`**

**Explicación:**

Las variables declaradas con `let` y `const` tienen **scope de bloque** es por este motivo que si bien tenemos 2 variables con el nombre `name`, ambas son diferentes e independientes en sus respectivos scopes.

La función `getName` intenta imprimir por consola `name` antes de ser declarada, por **hoisting** el interprete de JavaScript hará que `name` entre en lo que se denomina **Temporal Dead Zone**, una región del código donde la variable esta declarada pero no es posible acceder a ella.

Todo esto producirá un `ReferenceError`.

Si dentro de la función `getName` la variable `name` estuviera declara con `var`:

```js
function getName() {
  console.log(name)
  var name = 'Sarah'
}
```
Por **hoisting** el resultado seria `undefined` puesto que la **Temporal Dead Zone** solo existe con variables declaradas con `let` y `const`.

---

## Reto #64 {#sec-sol-array-64}

La respuesta del [Reto #64](#sec-array-64) es:

**A. `I love to program`**

**Explicación:**

Al usar los **backtiks de ES6**, las expresiones se evaluan primero.

En este caso la expresión completa es:

```js
${(x => x)('I love')}
```

Donde:
* `(x => x)` es una función anónima de tipo flecha, que recibe un parámetro `x` y con un **return implícito** lo devuelve.

* `('I love')` es la llamada a la función anónima, acá pasamos como argumento a la función la cadena `I love`.

Entonces, la función es llamada y regresa únicamente el parámetro que se le pasa. Por ello la respuesta es `I love to program`.

---

## Reto #65 {#sec-sol-array-65}

La respuesta del [Reto #65](#sec-array-65) es:

**C. `string`**

**Explicación:**

La función `sayHi` regresa una otra función de tipo flecha, dicha función es anónima y solo devuelve la cadena `Hi JavaScript`, el detalle acá es que esta función anónima una vez regresada es inmediatamente llamada.

Entonces `sayHi` será igual a la cadena `Hi Javascript` y en conclusión su `typeof` igual a `string`.

Podriamos ver también este ejemplo si extraemos la función anónima y escribimos en una función auxiliar por aparte, de la siguente manera:

```js
const aux = () => {
  return "Hi Javascript!"
}

const sayHi = () => {
  return aux();
}

console.log(typeof sayHi()); // string
```

---

## Reto #66 {#sec-sol-array-66}

La respuesta del [Reto #66](#sec-array-66) es:

**C. `{ name:"not name" }`**

**Explicación:**

El operador `??=` se llama **Logical Nullish Assignment** es un operador de corto circuito moderno que consiste en ejecutar porciones de código si evaluamos una condición como **nullish**, osea, como valor `null` o `undefined`.

Entonces, en el ejemplo, si `obj.name` evalua como **nullish**, ejecutamos `"not name"`.

Llamamos a la función `getName` pasandole un objeto vacío, entonces todas sus propiedades son `undefined` y por consecuencia `nullish`, por ello a `obj.name` se el asigna el valor `"not name"` y retornamos ese objeto.


---

## Reto #67 {#sec-sol-array-67}

La respuesta del [Reto #67](#sec-array-67) es:

**A. `Pedro`**

**Explicación:**

Inicialmente el objeto `person` tiene en la llave `name` la cadena `Fernando` pero luego hacemos `person.name = "Pedro"` que actualiza el valor de `name` perdiendo la cadena `Fernando`. 

---

## Reto #68 {#sec-sol-array-68}

La respuesta del [Reto #68](#sec-array-68) es:

**B. `true`, `false`**

**Explicación:**

Existe diferencias entre declarar la propiedad de un objeto como `undefined` o eliminarla con el operador unario `delete`.

El objeto `band` original no tiene la propiedad `voice`, pero lo agregamos con el valor `undefined`, entonces el objeto quedaria así:

```js
const band = {
  id:1,
  name: "Radiohead",
  "type of music": "Rock",
  albums: ["Pablo Honey", "Ok Computer", "In Rainbows"],
  voice: undefined
};
```

Pese a que el valor de `voice` es `undefined` la propiedad existe como tal dentro del objeto, es por ello que al verificarlo con el operador `in` obtenemos `true`.

Algo diferente pasa cuando eliminamos con `delete` la propiedad `tipe of music`, esta deja de existir en el objeto, no tiene ningún tipo de valor, ni siquiera `undefined`, el objeto quedaría así:

```js
const band = {
  id:1,
  name: "Radiohead",
  albums: ["Pablo Honey", "Ok Computer", "In Rainbows"],
  voice: undefined
};
```
Por ello al verificar nuevamente con `in` la existencia de una propiedad con la llave `type of music` obtenemos `false`.

---

## Reto #69 {#sec-sol-array-69}

La respuesta del [Reto #69](#sec-array-69) es:

**A. `Radiohead`**

**Explicación:**

En JavaScript hay dos maneras de acceder a las propiedades de un objeto, con la **notación de punto** y con la **notación de corchetes**.

Usamos la **notación de punto** cuando conocemos el nombre literal de la propiedad a la que queremos acceder. 

La `key` a la que accedemos con esta notación debe ser un nombre de variable válido.

La **notación de corchetes** se diferencia en que todo lo que este dentro de los corchetes debe ser un `string` y es evaluado por JavaScript como una expresión.

Por este motivo, cuando hacemos `console.log(band["na"+"me"])` el lenguaje evalua los corchetes concatenando las cadenas de texto y mostramos por consola `Radiohead`. 

---

## Reto #70 {#sec-sol-array-70}

La respuesta del [Reto #70](#sec-array-70) es:

**A. `true`, `false`, `15`, `10`**

**Explicación:**

Al trabajar con objetos en JavaScript hay que difereciar 2 aspectos fundamentales: **tener 2 referencias la mismo objeto** y **tener 2 objetos diferentes pero con las mismas propiedades**.

Al crear `objeto1` estamos reservando un espacio en memoria para guardar dicho objeto.

Cuando asignamos `objeto1` a `objeto2` lo único que hacemos es que ambos objetos apunten a la misma dirección de memoria donde esta almacenado el `objeto1`. En otras palabras, tanto `objeto1` y `objeto2` no son independientes el uno del otro, si modificamos uno el otro también se vera afectado.

Como ambos apuntan a la misma dirección de memoria entonces al usar el operador débil de comparación `==` obtenemos `true`.

Pero si comparamos el `objeto1` contra el `objeto3` tendremos `false` puesto que si bien ambos tienen las mismas propiedades, estan almacenados en direcciones de memoria diferentes.

Para finalizar, cuando hacemos:

```js
objeto1.valor = 15;
console.log(objeto2.valor);
console.log(objeto3.valor);
```
Modificamos el `valor` de `objeto1` pero como apuntan a la misma dirección de momoria entonces también modificamos el valor del `objeto2` a `15`.

El `objeto3` no sufre ningún cambio. 

---