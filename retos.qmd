# Retos {.unnumbered}

## Reto #1: Conversión rápida a number {#sec-array-1}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué crees que imprime el siguiente código?**

```js
const array = [true, 33, 9, "-2"];

const f = (arr) => {
  return arr.map(Number)
}
const result = f(array)
console.log(result)
```

**Pista:** Piensa en cómo `Number()` convierte diferentes tipos.

* A. `[1, 33, 9, -2]`
* B. `[boolean, 33, 9, string]`
* C. `[null, 33, 9, null]`
* D. `[undefined, 33, 9, undefined]`

**[Ver solución](#sec-sol-array-1)**

---

## Reto #2: Desestructuración de arreglos {#sec-array-2}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué crees que imprime el siguiente código?**

```js
const fruits = ["Mango", "Manzana", "Naranja", "Pera"];
const { 3:pear } = fruits;
console.log(pear);
```

**Pista:** Es simplemente una desestructuración de arreglos.

* A. `Uncaught TypeError : cannot read property`
* B. `TypeError: null is not an object (evaluating)`
* C. `Naranja`
* D. `Pera`

**[Ver solución](#sec-sol-array-2)**

---

## Reto #3: Igualdad débil vs Igualdad estricta {#sec-array-3}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
console.log(false == 0) // true
console.log(false === 0) // false
```

**Pista:** Notar la comparación de variables con igualdad débil e igualdad estricta.

**[Ver solución](#sec-sol-array-3)**

---

## Reto #4: Comparación de valores falsy {#sec-array-4}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
console.log(false == null); // false
console.log(false == undefined); // false
```

Siendo `null` y `undefined` valores falsy, ¿por qué pasa esto?

**Pista:** Notar que todos los valores de la comparación son considerados valores falsy para el interprete de JavaScript 

**[Ver solución](#sec-sol-array-4)**

---

## Reto #5: Igualdad estricta con `NaN` {#sec-array-5}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
console.log(NaN === NaN) // false
```

¿Por qué pasa esto?

**Pista:** Piensa en la naturaleza de `NaN`. 

**[Ver solución](#sec-sol-array-5)**

---

## Reto #6: Copia de objetos por referencia  {#sec-array-6}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
let c = { greeting: "Hey!" };
let d;

d = c;
c.greeting = "Hello";
console.log(d.greeting);
```

**Pista:** Recordar las diferencias de las copias por valor y copias por referencia.

* A. `Hello`
* B. `undefined`
* C. `ReferenceError`
* D. `TypeError`

**[Ver solución](#sec-sol-array-6)**

---

## Reto #7: El operador `+` y `!`  {#sec-array-7}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(+true);
console.log(!"Messi")
```

**Pista:** Recuerda los conceptos de valores falsy y truthy.

* A. `1`, `false`
* B. `false`, `NaN`
* C. `false`, `false`
* D. `Ninguno de los anteriores`

**[Ver solución](#sec-sol-array-7)**

---

## Reto #8: Comparaciones entre primitivos y objetos {#sec-array-8}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

**Pista:** Notar la diferencia entre `==` y `===`. Notar que `b` es un objeto y no primitivo.

* A. `true`, `false`, `true`
* B. `false`, `false`, `true`
* C. `true`, `false`, `false`
* D. `false`, `true`, `true`

**[Ver solución](#sec-sol-array-8)**

---

## Reto #9: Una curiosidad sobre funciones  {#sec-array-9}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
function bark() {
  console.log("Woof!");
}

bark.animal = "dog";
```

**Pista:** Todo en JavaScript es una función.

* A. `No pasa nada, es totalmente correcto.`
* B. `SyntaxError. No es posible agregar propiedades a una función de esta manera.`
* C. `undefined`
* D. `ReferenceError`

**[Ver solución](#sec-sol-array-9)**

---

## Reto #10: Variables sin `var`, `let` o `const` {#sec-array-10}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let greeting;
greetign = {}; // Typo!
console.log(greetign);
```

**Pista:** ¿Qué pasa cuando declaramos una variable sin `var`, `let` o `const`? ¿Piensas que es posible hacer algo así o tendremos algún tipo de error por parte de JavaScript?

* A. `{}`
* B. `ReferenceError: greetign is not defined`
* C. `undefined`
* D. `Ninguna de las anteriores`

**[Ver solución](#sec-sol-array-10)**

---


## Reto #11: Operadores `+` y `-` con cadenas y números {#sec-array-11}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const x = "111"
const y = 11
let z = "1"

console.log(x + y)
console.log(y - z)
```

**Pista:** Diferenciar una suma artimética de una concatenación de cadenas.

* A. `122`, `10`
* B. `"11111"`, `1`
* C. `"11111"`, `10`
* D. `122`, `"111"`

**[Ver solución](#sec-sol-array-11)**

---

## Reto #12: Comparación de objetos {#sec-array-12}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("You are an adult!");
  } else if (data == { age: 18 }) {
    console.log("You are still an adult.");
  } else {
    console.log(`Hmm... You don't have an age I guess`);
  }
}

const result = checkAge({ age: 18 });
console.log(result);
```

**Pista:** Recordar que los objetos se almacenan en memoria teniendo en cuenta su **referencia** y no su **valor**.

* A. `You are an adult!`
* B. `You are still an adult.`
* C. `Hmm... You don't have an age I guess`
* D. `Ninguna de las anteriores`

**[Ver solución](#sec-sol-array-12)**

---

## Reto #13: Parámetros REST {#sec-array-13}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

**Pista:** Los parámetros REST permiten pasar un número variable de argumentos a una función.

* A. `number`
* B. `array`
* C. `objet`
* D. `NaN`

**[Ver solución](#sec-sol-array-13)**

---

## Reto #14: `typeof` de expresiones extrañas {#sec-array-14}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(typeof([] + []));
```

**Pista:** Recuerda el el operador `+` sirve para hacer concatenaciones de cadenas.

* A. `undefined`
* B. `number`
* C. `object`
* D. `string`

**[Ver solución](#sec-sol-array-14)**

---

## Reto #15: Objetos y conjuntos {#sec-array-15}

::: {.callout-caution title="Dificultad" collapse="true"}
**Avanzado**
:::

**¿Qué imprime este código?**

```js
const obj = { 1: "a", 2: "b", 3: "c" };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty("1");
obj.hasOwnProperty(1);
set.has("1");
set.has(1);
```

**Pista:** Recuerda que un `set` no es lo mismo que un objeto.

* A. `false`, `true`, `false`, `true`
* B. `false`, `true`, `true`, `true`
* C. `true`, `true`, `false`, `true`
* D. `true`, `true`, `true`, `true`

**[Ver solución](#sec-sol-array-15)**

---

## Reto #16: Una curiosidad sobre los objetos {#sec-array-16}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const obj = { a: "one", b: "two", a: "three" };
console.log(obj);
```

**Pista:** Los objetos son estructuras de datos no indexadas.

* A. `{ a: "one", b: "two" }`
* B. `{ b: "two", a: "three" }`
* C. `{ a: "three", b: "two" }`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-16)**

---

## Reto #17: Hablemos sobre prototipos  {#sec-array-17}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
String.prototype.giveLydiaPizza = () => {
  return "Just give Lydia pizza already!";
};

const name = "Lydia";

name.giveLydiaPizza();
```

**Pista:** Los objetos son estructuras de datos no indexadas.

* A. `"Just give Lydia pizza already!"`
* B. `TypeError: not a function`
* C. `SyntaxError`
* D. `undefined`

**[Ver solución](#sec-sol-array-17)**

---

## Reto #18: Simulando asincronía con `setTimeOut()` {#sec-array-18}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"));
const baz = () => console.log("Third");

bar();
foo();
baz();
```

**Pista:** `setTimeout` es una Web API.

* A. `First`, `Second`, `Third`
* B. `First`, `Third`, `Second`
* C. `Second`, `First`, `Third`
* D. `Second`, `Third`, `First`

**[Ver solución](#sec-sol-array-18)**

---

## Reto #19: `typeof` de `typeof` {#sec-array-19}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(typeof typeof 1);
```

**Pista:** `typeof` retorna un primitivo. ¿Pero cuál?

* A. `number`
* B. `string`
* C. `object`
* D. `undefined`

**[Ver solución](#sec-sol-array-19)**

---

## Reto #20: Posiciones indexadas de un arreglo {#sec-array-20}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
```

**Pista:** Los arreglos en JavaScript son muy permisivos.

* A. `[1, 2, 3, 7 x null, 11]`
* B. `[1, 2, 3, 11]`
* C. `[1, 2, 3, 7 x empty, 11]`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-20)**

---

## Reto #21: Entendiendo `reduce` con matrices  {#sec-array-21}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2]
);
```

**Pista:** El segundo parámetro de `reduce` es el valor inicial de `acc`.

* A. `[0, 1, 2, 3, 1, 2]`
* B. `[6, 1, 2]`
* C. `[1, 2, 0, 1, 2, 3]`
* D. `[1, 2, 6]`

**[Ver solución](#sec-sol-array-21)**

---

## Reto #22: El operador de doble negación  {#sec-array-22}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(!!null);
console.log(!!"");
console.log(!!1);
```

**Pista:** El operador `!!` convierte un valor en su equivalente booleano.

* A. `false`, `true`, `false`
* B. `false`, `false`, `true`
* C. `false`, `true`, `true`
* D. `true`, `true`, `false`

**[Ver solución](#sec-sol-array-22)**

---

## Reto #23: Uso de `setInterval` {#sec-array-23}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
setInterval(() => console.log("Hi"), 1000);
```

**Pista:** `setInterval` es una Web API que se ejecuta cada x milisegundos.

* A. `1000`
* B. `Hi 1000 veces`
* C. `Hi cada segundo`
* D. `undefined`

**[Ver solución](#sec-sol-array-23)**

---

## Reto #24: Spread operator con cadenas {#sec-array-24}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log([..."Oscar"])
```

**Pista:** El **spread operator** permite expandir un iterable en sus elementos.

* A. `["O", "s", "c", "a", "r"]`
* B. `["Oscar"]`
* C. `[[], "Oscar"]`
* D. `[["O", "s", "c", "a", "r"]]`

**[Ver solución](#sec-sol-array-24)**

---

## Reto #25: Objeto por referencia {#sec-array-25}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let person = { name: "Carmen" };
const members = [person];
person = null;

console.log(members);
```

**Pista:** Los objetos pasan sus valores por referencia.

* A. `null`
* B. `[null]`
* C. `[{}]`
* D. `[{ name: "Carmen" }]`

**[Ver solución](#sec-sol-array-25)**

---

## Reto #26: El bucle `for...in` con objetos {#sec-array-26}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const person = {
  name: "Carla",
  age: 26
};

for (const item in person) {
  console.log(item);
}
```

**Pista:** El bucle `for...in` no itera sobre los valores de un objeto.

* A. `{ name: "Carla" }`, `{ age: 26 }`
* B. `"name"`, `"age"`
* C. `"Carla"`, `26`
* D. `["name", "Carla"]`, `["age", 26]`

**[Ver solución](#sec-sol-array-26)**

---

## Reto #27: ¿Concatenaciones o sumas aritméticas? {#sec-array-27}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(3 + 4 + "5");
```

**Pista:** Los números se suman, las cadenas se concatenan.

* A. `"345"`
* B. `"75"`
* C. `12`
* D. `75`

**[Ver solución](#sec-sol-array-27)**

---

## Reto #28: Conversiones con `parseInt()` {#sec-array-28}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const num = parseInt("7*6", 10);
console.log(num); 
```

**Pista:** `parseInt()` convierte un número a una base númerica dada.

* A. `42`
* B. `"42"`
* C. `7`
* D. `NaN`

**[Ver solución](#sec-sol-array-28)**

---

## Reto #29: Transformaciones de arreglos con `map()` {#sec-array-29}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
[1, 2, 3].map(num => {
  if (typeof num === "number") return;
  return num * 2;
});
```

**Pista:** Ojo con la sentencia `return`

* A. `[]`
* B. `[null, null, null]`
* C. `[undefined, undefined, undefined]`
* D. `[ 3 huecos vacíos ]`

**[Ver solución](#sec-sol-array-29)**

---

## Reto #30: Alcance de variables {#sec-array-30}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let x = 10;
if (true) {
  let y = 20;
  var z = 30;
  console.log(x + y + z);
}
console.log(x + z);
```

**Pista:** Diferenciar los diferentes alcances de las variables con `let` y `var`.

* A. `60`, `40`
* B. `undefined`, `10`
* C. `50`, `10`
* D. `null`, `40`

**[Ver solución](#sec-sol-array-30)**

---

## Reto #31: Otra desestructuración de arreglos {#sec-array-31}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const fn = () => {
  return [1000, 9000+1]
}

const [, second] = fn()
console.log(second.toString())
```

**Pista:** Es posible omitir posiciones no deseadas del arreglo usando `,` en la desestructuración.

* A. `1000`
* B. `9001`
* C. `"9001"`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-31)**

---

## Reto #32: Funciones Tradicionales vs Funciones Flecha {#sec-array-32}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**Explica este código JavaScript**

¿Cuál es la diferencia entre las siguientes funciones?

```js
function addTraditional(a, b){
  return a + b;
}

const addArrow = (a, b) => {
  return a + b;
}
```

**Pista:** No tiene nada que ver con la sintaxis.

* A. `No hay diferencia, son exactamente iguales.`
* B. `La primera función es más rápida que la segunda.`
* C. `La primera función tiene hoisting, la segunda no.`
* D. `Solo cambia la sintaxis, luego son iguales.`

**[Ver solución](#sec-sol-array-32)**

---

## Reto #33: Excepciones con `try...catch` {#sec-array-33}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function greeting() {
  throw "Hello world!";
}

function sayHi() {
  try {
    const data = greeting();
    console.log("It worked!", data);
  } catch (e) {
    console.log("Oh no an error!", e);
  }
}

sayHi();
```

**Pista:** La sentencia `catch` siempre atrapa los errores.

* A. `"It worked! Hello world!"`
* B. `"Oh no an error!" undefined`
* C. `SyntaxError: can only throw Error objects`
* D. `"Oh no an error! Hello world!"`

**[Ver solución](#sec-sol-array-33)**

---

## Reto #34: Spread operator con objetos {#sec-array-34}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const user = { name: "Hernan", age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
```

**Pista:** El **spread operator** expande las propiedades del objeto. 

* A. `{ admin: true, user: { name: "Hernan", age: 21 } }`
* B. `{ admin: true, name: "Hernan", age: 21 }`
* C. `{ admin: true, user: ["Hernan", 21] }`
* D. `{ admin: true }`

**[Ver solución](#sec-sol-array-34)**

---

## Reto #35: El segundo parámetro de `JSON.stringify` {#sec-array-35}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const settings = {
  username: "asterion",
  level: 80,
  health: 25
};

const data = JSON.stringify(settings, ["level", "health"]);
console.log(data);
```

**Pista:** `JSON.stringify` convierte un objeto a cadena. 

* A. `'{"level":80, "health":25}'`
* B. `'{"username": "asterion"}'`
* C. `'["level", "health"]'`
* D. `'{"username": "asterion", "level":80, "health":25}'`

**[Ver solución](#sec-sol-array-35)**

---

## Reto #36: Alcance de variables y paso de parámetros {#sec-array-36}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
```

**Pista:** La variable `num` tiene alcance global.

* A. `10`, `10`
* B. `10`, `11`
* C. `11`, `11`
* D. `11`, `12`

**[Ver solución](#sec-sol-array-36)**

---

## Reto #37: Multiples llamadas a una función {#sec-array-37}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log((x.number *= 2));
};

multiply();
multiply();
multiply(value);
multiply(value);
```

**Pista:** Atención al objeto como parámetro en la función y los valores por defecto.

* A. `20`, `40`, `80`, `160`
* B. `20`, `40`, `20`, `40`
* C. `20`, `20`, `20`, `40`
* D. `NaN`, `NaN`, `20`, `40`

**[Ver solución](#sec-sol-array-37)**

---

## Reto #38: `Number`, `Boolean`, `Symbol` {#sec-array-38}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(Number(2) === Number(2))
console.log(Boolean(false) === Boolean(false))
console.log(Symbol('foo') === Symbol('foo'))
```

**Pista:** Cuidado con las comparaciones entre primitivos `Symbol`.

* A. `true`, `true`, `false`
* B. `false`, `true`, `false`
* C. `true`, `false`, `true`
* D. `true`, `true`, `true`

**[Ver solución](#sec-sol-array-38)**

---

## Reto #39: Funciones asíncronas {#sec-array-39}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
async function getData() {
  return await Promise.resolve("I made it!");
}

const data = getData();
console.log(data);
```

**Pista:** Las promesas son objetos especiales de JavaScript que solo tienen tres posibles estados: promesa resuelta, promesa rechazada o promesa pendiente.

* A. `"I made it!"`
* B. `Promise {<resolved>: "I made it!"}`
* C. `Promise {<pending>}`
* D. `undefined`

**[Ver solución](#sec-sol-array-39)**

---

## Reto #40: `Array.push` {#sec-array-40}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function addToList(item, list) {
  return list.push(item);
}

const result = addToList("apple", ["banana"]);
console.log(result);
```

**Pista:** ¿El método `push` de los arreglos solo agrega un elemento al final de un arreglo?

* A. `['banana', 'apple']`
* B. `2`
* C. `true`
* D. `undefined`

**[Ver solución](#sec-sol-array-40)**

---

## Reto #41: `for...of` vs `for...in`  {#sec-array-41}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const bands = ["Radiohead", "Coldplay", "Nirvana"]

for (let item in bands) {
  console.log(item)
}

for (let item of bands) {
  console.log(item)
}
```

**Pista:** Ambos sirven para iterar pero no son lo mismo.

* A. `0 1 2` y `"Radiohead" "Coldplay" "Nirvana"`
* B. `"Radiohead" "Coldplay" "Nirvana"` y `"Radiohead" "Coldplay" "Nirvana"`
* C. `"Radiohead" "Coldplay" "Nirvana"` y `0 1 2`
* D. `0 1 2` y `{0: "Radiohead", 1: "Coldplay", 2: "Nirvana"}`

**[Ver solución](#sec-sol-array-41)**

---

## Reto #42: Expresiones en elementos de arreglos {#sec-array-42}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const list = [1 + 2, 1 * 2, 1 / 2]
console.log(list)
```

**Pista:** Los elementos de un arreglo pueden contener expresiones a ser evaluadas por el interprete de JavaScript.

* A. `["1 + 2", "1 * 2", "1 / 2"]`
* B. `["12", 2, 0.5]`
* C. `[3, 2, 0.5]`
* D. `[1, 1, 1]`

**[Ver solución](#sec-sol-array-42)**

---

## Reto #43: Olvidar el parámetro de la función {#sec-array-43}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function sayHi(name) {
  return `Hi there, ${name}`
}

console.log(sayHi())
```

**Pista:** No imprime ningún tipo de error.

* A. `Hi there`
* B. `Hi there, undefined`
* C. `Hi there, null`
* D. `ReferenceError`

**[Ver solución](#sec-sol-array-43)**

---

## Reto #44: Otra vez el alcance de las variables {#sec-array-44}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
var status = "A"

setTimeout(() => {
  const status = "B"

  const data = {
    status: "C",
    getStatus() {
      return this.status
    }
  }
  console.log(data.getStatus())
}, 0)
```

**Pista:** `var` tiene scope de función mientras que `const`scope de bloque.

* A. `"C"`
* B. `"B"`
* C. `"A"`
* D. `ReferenceError`

**[Ver solución](#sec-sol-array-44)**

---

## Reto #45: `const` y el alcance de bloque {#sec-array-45}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function checkAge(age) {
  if (age < 18) {
    const message = "Sorry, you're too young."
  } else {
    const message = "Yay! You're old enough!"
  }
  return message
}

console.log(checkAge(21))
```

**Pista:** El valor de una variable `const` solo existe en el bloque donde fue declarada.

* A. `"Sorry, you're too young."`
* B. `"Yay! You're old enough!"`
* C. `ReferenceError`
* D. `undefined`

**[Ver solución](#sec-sol-array-45)**

---

## Reto #46: I want pizza {#sec-array-46}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log("I want pizza"[0])
```

**Pista:** Las cadenas, al igual que los arreglos, son elementos iterables.

* A. `"""`
* B. `"I"`
* C. `SyntaxError`
* D. `undefined`

**[Ver solución](#sec-sol-array-46)**

---

## Reto #47: Parámetros de funciones y valores por defecto {#sec-array-47}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function sum(num1, num2 = num1) {
  console.log(num1 + num2)
}

sum(10)
```

**Pista:** Los parámetros por defecto toman el valor pertinente cuando no proporcionamos el argumento correspondiente.

* A. `NaN`
* B. `20`
* C. `ReferenceError`
* D. `undefined`

**[Ver solución](#sec-sol-array-47)**

---

## Reto #48: Otra vez el método `push`  {#sec-array-48}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
let newList = [1, 2, 3].push(4)

console.log(newList.push(5))
```

**Pista:** Notar que no estamos imprimiendo el arreglo `newList` suelto, sino usando el método `push`.

* A. `[1, 2, 3, 4, 5]`
* B. `[1, 2, 3, 5]`
* C. `[1, 2, 3, 4]`
* D. `TypeError: newList.push is not a function`

**[Ver solución](#sec-sol-array-48)**

---

## Reto #49: `Object.entries` para iterar objetos {#sec-array-49}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const person = {
  name: "Robert",
  age: 30
}

for (const [x, y] of Object.entries(person)) {
  console.log(x, y)
}
```

**Pista:** Notar la desestructuración de variables en el bucle `for...of`.

* A. `name Robert` y `age 30`
* B. `["name", "Robert"]` y `["age", 30]`
* C. `["name", "age"]` y `undefined`
* D. `SyntaxError`


**[Ver solución](#sec-sol-array-49)**

---

## Reto #50: Parametros REST en funciones modernas {#sec-array-50}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function getItems(fruitList, ...args, favoriteFruit) {
  return [...fruitList, ...args, favoriteFruit]
}

getItems(["banana", "apple"], "pear", "orange")
```

**Pista:** Cuidado con el orden de los parámetros en las funciones.

* A. `["banana", "apple", "pear", "orange"]`
* B. `[["banana", "apple"], "pear", "orange"]`
* C. `["banana", "apple", ["pear"], "orange"]`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-50)**

---

## Reto #51: Una función rara {#sec-array-51}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function nums(a, b) {
  if
  (a > b)
  console.log('a is bigger')
  else 
  console.log('b is bigger')
  return 
  a + b
}

console.log(nums(4, 2))
console.log(nums(1, 2))
```

**Pista:** Notar que no existe ningún punto y coma en núnguna línea de código de la función.

* A. `a is bigger, 6 y b is bigger, 3`
* B. `a is bigger, undefined y b is bigger, undefined`
* C. `undefined y undefined`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-51)**

---

## Reto #52: El primitivo `Symbol` {#sec-array-52}

::: {.callout-caution title="Dificultad" collapse="true"}
**Avanzado**
:::

**¿Qué imprime este código?**

```js
const info = {
  [Symbol('a')]: 'b'
}

console.log(info)
console.log(Object.keys(info))
```

**Pista:** `Symbol` es un primitivo relativamente nuevo en JavaScript que permite crear valores únicos e irrepetibles. 

* A. `{Symbol('a'): 'b'}` y `["{Symbol('a')"]`
* B. `{}` y `[]`
* C. `{ a: "b" }` y `["a"]`
* D. `{Symbol('a'): 'b'}` y `[]`

**[Ver solución](#sec-sol-array-52)**

---

## Reto #53: Cuidado con el return implicito de las funciones {#sec-array-53}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const getList = ([x, ...y]) => [x, y]
const getUser = user => { name: user.name, age: user.age }

const list = [1, 2, 3, 4]
const user = { name: "Messi", age: 40 }

console.log(getList(list))
console.log(getUser(user))
```

**Pista:** Cuidado con la sintaxis de **return implícito** en las funciones flecha.

* A. `[1, [2, 3, 4]]` y `SyntaxError`
* B. `[1, [2, 3, 4]]` y `{ name: "Messi", age: 40 }`
* C. `[1, 2, 3, 4]` y `{ name: "Messi", age: 40 }`
* D. `SyntaxError` y `{ name: "Messi", age: 40 }`

**[Ver solución](#sec-sol-array-53)**

---




## Reto #54: Invocar una variable como función {#sec-array-54}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const name = "Pepe"
console.log(name())
```

**Pista:** Las variables no pueden ser invocadas como funciones, ¿o si pueden?

* A. ´SyntaxError`
* B. ´ReferenceError`
* C. ´TypeError`
* D. ´undefined`

**[Ver solución](#sec-sol-array-54)**

--- 

## Reto #55: Backticks y el operador de corto circuito `and` {#sec-array-55}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const output = `${[] && 'Im'}possible!
You should${'' && `n't`} see a therapist after so much JavaScript lol`
```

**Pista:** Recordar las tablas de verdad para saber cuando se ejecuta el operador de corto circuito.

* A. `possible! You should see a therapist after so much JavaScript lol`
* B. `Impossible! You should see a therapist after so much JavaScript lol`
* C. `possible! You shouldn't see a therapist after so much JavaScript lol`
* D. `Impossible! You shouldn't see a therapist after so much JavaScript lol`

**[Ver solución](#sec-sol-array-55)**

---

## Reto #56: El operador de corto circuito `or` {#sec-array-56}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const one = (false || {} || null)
const two = (null || false || "")
const three = ([] || 0 || true)

console.log(one, two, three)
```

**Pista:** El operador de corto circuito ´or´ se ejecuta con valores **falsy**.

* A. `false` `null` `[]`
* B. `null` `""` `true`
* C. `{}` `""` `[]`
* D. `null` `null` `true`

**[Ver solución](#sec-sol-array-56)**

---

## Reto #57: Promesas y funciones asíncronas {#sec-array-57}

::: {.callout-caution title="Dificultad" collapse="true"}
**Avanzado**
:::

**¿Qué imprime este código?**

```js
const myPromise = () => Promise.resolve('I have resolved!')

function firstFunction() {
  myPromise().then(res => console.log(res))
  console.log('second')
}

async function secondFunction() {
  console.log(await myPromise())
  console.log('second')
}

firstFunction()
secondFunction()
```

**Pista:** Recordar que cuando tenemos sintaxis `async await` escribimos código de manera síncrona pero se ejecuta de manera asíncrona.

* A. `I have resolved!`, `second` y `I have resolved!`, `second`
* B. `second`, `I have resolved!` y `second`, `I have resolved!`
* C. `I have resolved!`, `second` y `second`, `I have resolved!`
* D. `second`, `I have resolved!` y `I have resolved!`, `second`

**[Ver solución](#sec-sol-array-57)**

---

## Reto #58: Conjuntos en JavaScript {#sec-array-58}

::: {.callout-caution title="Dificultad" collapse="true"}
**Avanzado**
:::

**¿Qué imprime este código?**

```js
const set = new Set()

set.add(1)
set.add("Cris")
set.add({ name: "Cris" })

for (let item of set) {
  console.log(item + 2)
}
```

**Pista:** Recordar que el operador `+` puede ser usado para sumar números y para concatenar cadenas de texto.

* A. `3`, `NaN`, `NaN`
* B. `3`, `7`, `NaN`
* C. `3`, `Cris2`, `[Object object]2`
* D. `"12"`, `Cris2`, `[Object object]2`

**[Ver solución](#sec-sol-array-58)**

---

## Reto #59: Objetos y sus referencias {#sec-array-59}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function compareMembers(person1, person2 = person) {
  if (person1 !== person2) {
    console.log("Not the same!")
  } else {
    console.log("They are the same!")
  }
}

const person = { name: "Allan" }

compareMembers(person)
```

**Pista:** Cuidado con las referencias de los objetos.

* A. `Not the same!`
* B. `They are the same!`
* C. `ReferenceError`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-59)**

---

## Reto #60: Acceso a propiedades de objetos {#sec-array-60}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const colorConfig = {
  red: true,
  blue: false,
  green: true,
  black: true,
  yellow: false,
}

const colors = ["pink", "red", "blue"]

console.log(colorConfig.colors[1])
```

**Pista:** Recuerda que las propiedades de los objetos son accedidas por medio de `.` y los arreglos son accedidos por medio de `[]`.

* A. `true`
* B. `false`
* C. `undefined`
* D. `TypeError`

**[Ver solución](#sec-sol-array-60)**

---

## Reto #61: Métodos de arreglo inmutables {#sec-array-61}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Cuál o cuales de estos métodos modifica el array original?**

```js
const points = ['.', '..', '...']

emojis.map(x => x + '.')
emojis.filter(x => x !== '..')
emojis.find(x => x !== '..')
emojis.reduce((acc, cur) => acc + '.')
emojis.slice(1, 2, '.') 
emojis.splice(1, 2, '.')
```

**Pista:** Los métodos inmutables no modifican el arreglo original.

* A. `Todos los anteriores`
* B. `map`, `reduce`, `slice`, `splice`
* C. `map`, `slice`, `splice`
* D. `splice`

**[Ver solución](#sec-sol-array-61)**

---

## Reto #62: Acceso a propiedades de objetos y elementos de arreglos {#sec-array-62}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const food = ['pizza', 'chocolat', 'avocat', 'egg']
const info = { favoriteFood: food[0] }

info.favoriteFood = 'apple'

console.log(food)
```

**Pista:** La notación de punto sirve para acceder a propiedades de objetos y la notación de corchetes para acceder a elementos de arreglos.

* A. `['pizza', 'chocolat', 'avocat', 'egg']`
* B. `['apple', 'chocolat', 'avocat', 'egg']`
* C. `['apple', 'pizza', 'chocolat', 'avocat', 'egg']`
* D. `ReferenceError`

**[Ver solución](#sec-sol-array-62)**

---

## Reto #63: Temporal Dead Zone {#sec-array-63}

::: {.callout-caution title="Dificultad" collapse="true"}
**Avanzado**
:::

**¿Qué imprime este código?**

```js
let name = 'Abigail'

function getName() {
  console.log(name)
  let name = 'Norah'
}

getName()
```

**Pista:** Cuidado con los scopes de las variables, no es lo mismo una variable con scope global y una variable con scope de bloque.

* A. `Abigail`
* B. `Norah`
* C. `undefined`
* D. `ReferenceError`

**[Ver solución](#sec-sol-array-63)**

---

## Reto #64: Interpolación de cadenas {#sec-array-64}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(`${(x => x)('I love')} to program`)
```

**Pista:** En las plantillas con backticks, todo lo que este dentro de `{}` se evalua como una expresión de JavaScript.

* A. `I love to program`
* B. `undefined to program`
* C. `${(x => x)('I love') to program`
* D. `TypeError`

**[Ver solución](#sec-sol-array-64)**

---

## Reto #65: `typeof` y funciones {#sec-array-65}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const sayHi = () => {
  return (() =>"Hi Javascript!")();
}

console.log(typeof sayHi());
```

**Pista:** Ojo con el valor de retorno de la función `sayHi`.

* A. `number`
* B. `object`
* C. `string`
* D. `TypeError`

**[Ver solución](#sec-sol-array-65)**

---

## Reto #66: Logical Nullish Assignment {#sec-array-66}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const getName = (obj) => {
  obj.name ??= "not name";
  return obj;
}
console.log(getName({}))
```

**Pista:** Recuerda que un valor **nullish** es aquel que evalua `undefined` o `null`.

* A. `undefined`
* B. `{}`
* C. `{ name:"not name" }`
* D. `Ninguno de los anteriores`

**[Ver solución](#sec-sol-array-66)**

---

## Reto #67: Actulizar propiedades de objetos {#sec-array-67}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const person = {
  id: 1,
  name:"Fernando",
};
person.name = "Pedro";
console.log(persona.nombre);
```

**Pista:** Podemos actualizar valores de una propiedad de un objeto con la notación de punto.

* A. `Pedro`
* B. `Fernando`
* C. `null`
* D. `TypeError`

**[Ver solución](#sec-sol-array-67)**

---

## Reto #68: Operador `in` y eliminación de propiedades {#sec-array-68}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const band = {
  id:1,
  name: "Radiohead",
  "type of music": "Rock",
  albums: ["Pablo Honey", "Ok Computer", "In Rainbows"]
};

band.voice = undefined;
console.log("voice" in band);
delete band["type of music"];
console.log("type of music" in band);
```

**Pista:** `in` sirve para poder verificar si una propiedad existe en un objeto.

* A. `false`, `false`
* B. `true`, `false`
* C. `false`, `true`
* D. `undefined`, `true`

**[Ver solución](#sec-sol-array-68)**

---

## Reto #69: Propiedades dinámicas de objetos {#sec-array-69}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const band = {
  id:1,
  name: "Radiohead",
  "tipe of music": "Rock",
  albums: ["Pablo Honey", "Ok Computer", "In Rainbows"]
};

console.log(band["na"+"me"])
```

**Pista:** La notación de corchetes en los objetos permite acceder a propiedades usando una expresión como clave.

* A. `Radiohead`
* B. `undefined`
* C. `name`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-69)**

---

## Reto #70: Más objetos y valores por referencia {#sec-array-70}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let objeto1 = { valor: 10 };
let objeto2 = objeto1;
let objeto3 = { valor: 10 };

console.log(objeto1 == objeto2);
console.log(objeto1 == objeto3);

objeto1.valor = 15;
console.log(objeto2.valor);
console.log(objeto3.valor);
```

**Pista:** Recuerda cómo funcionan las referencias en JavaScript con los objetos. Piensa en cómo se comportan las asignaciones de objetos y las comparaciones de igualdad con el operador `==`.

* A. `true`, `false`, `15`, `10`
* B. `false`, `true`, `10`, `20`
* C. `true`, `true`, `15`, `20`
* D. `false`, `false`, `20`, `15`

**[Ver solución](#sec-sol-array-70)**

---

