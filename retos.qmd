# Retos {.unnumbered}

## Reto #1: Conversión rápida a number {#sec-array-1}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué crees que imprime el siguiente código?**

```js
const array = [true, 33, 9, "-2"];

const f = (arr) => {
  return arr.map(Number)
}
const result = f(array)
console.log(result)
```

**Pista:** Piensa en cómo `Number()` convierte diferentes tipos.

* A. `[1, 33, 9, -2]`
* B. `[boolean, 33, 9, string]`
* C. `[null, 33, 9, null]`
* D. `[undefined, 33, 9, undefined]`

**[Ver solución](#sec-sol-array-1)**

---

## Reto #2: Desestructuración de arreglos {#sec-array-2}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué crees que imprime el siguiente código?**

```js
const fruits = ["Mango", "Manzana", "Naranja", "Pera"];
const { 3:pear } = fruits;
console.log(pear);
```

**Pista:** Es simplemente una desestructuración de arreglos.

* A. `Uncaught TypeError : cannot read property`
* B. `TypeError: null is not an object (evaluating)`
* C. `Naranja`
* D. `Pera`

**[Ver solución](#sec-sol-array-2)**

---

## Reto #3: Igualdad débil vs Igualdad estricta {#sec-array-3}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
console.log(false == 0) // true
console.log(false === 0) // false
```

**Pista:** Notar la comparación de variables con igualdad débil e igualdad estricta.

**[Ver solución](#sec-sol-array-3)**

---

## Reto #4: Comparación de valores falsy {#sec-array-4}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
console.log(false == null); // false
console.log(false == undefined); // false
```

Siendo `null` y `undefined` valores falsy, ¿por qué pasa esto?

**Pista:** Notar que todos los valores de la comparación son considerados valores falsy para el interprete de JavaScript 

**[Ver solución](#sec-sol-array-4)**

---

## Reto #5: Igualdad estricta con `NaN` {#sec-array-5}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
console.log(NaN === NaN) // false
```

¿Por qué pasa esto?

**Pista:** Piensa en la naturaleza de `NaN`. 

**[Ver solución](#sec-sol-array-5)**

---

## Reto #6: Copia de objetos por referencia  {#sec-array-6}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Puedes explicar el siguiente código?**

```js
let c = { greeting: "Hey!" };
let d;

d = c;
c.greeting = "Hello";
console.log(d.greeting);
```

**Pista:** Recordar las diferencias de las copias por valor y copias por referencia.

* A. `Hello`
* B. `undefined`
* C. `ReferenceError`
* D. `TypeError`

**[Ver solución](#sec-sol-array-6)**

---

## Reto #7: El operador `+` y `!`  {#sec-array-7}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(+true);
console.log(!"Messi")
```

**Pista:** Recuerda los conceptos de valores falsy y truthy.

* A. `1`, `false`
* B. `false`, `NaN`
* C. `false`, `false`
* D. `Ninguno de los anteriores`

**[Ver solución](#sec-sol-array-7)**

---

## Reto #8: Comparaciones entre primitivos y objetos {#sec-array-8}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

**Pista:** Notar la diferencia entre `==` y `===`. Notar que `b` es un objeto y no primitivo.

* A. `true`, `false`, `true`
* B. `false`, `false`, `true`
* C. `true`, `false`, `false`
* D. `false`, `true`, `true`

**[Ver solución](#sec-sol-array-8)**

---

## Reto #9: Una curiosidad sobre funciones  {#sec-array-9}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
function bark() {
  console.log("Woof!");
}

bark.animal = "dog";
```

**Pista:** Todo en JavaScript es una función.

* A. `No pasa nada, es totalmente correcto.`
* B. `SyntaxError. No es posible agregar propiedades a una función de esta manera.`
* C. `undefined`
* D. `ReferenceError`

**[Ver solución](#sec-sol-array-9)**

---

## Reto #10: Variables sin `var`, `let` o `const` {#sec-array-10}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let greeting;
greetign = {}; // Typo!
console.log(greetign);
```

**Pista:** ¿Qué pasa cuando declaramos una variable sin `var`, `let` o `const`? ¿Piensas que es posible hacer algo así o tendremos algún tipo de error por parte de JavaScript?

* A. `{}`
* B. `ReferenceError: greetign is not defined`
* C. `undefined`
* D. `Ninguna de las anteriores`

**[Ver solución](#sec-sol-array-10)**

---


## Reto #11: Operadores `+` y `-` con cadenas y números {#sec-array-11}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const x = "111"
const y = 11
let z = "1"

console.log(x + y)
console.log(y - z)
```

**Pista:** Diferenciar una suma artimética de una concatenación de cadenas.

* A. `122`, `10`
* B. `"11111"`, `1`
* C. `"11111"`, `10`
* D. `122`, `"111"`

**[Ver solución](#sec-sol-array-11)**

---

## Reto #12: Comparación de objetos {#sec-array-12}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("You are an adult!");
  } else if (data == { age: 18 }) {
    console.log("You are still an adult.");
  } else {
    console.log(`Hmm... You don't have an age I guess`);
  }
}

const result = checkAge({ age: 18 });
console.log(result);
```

**Pista:** Recordar que los objetos se almacenan en memoria teniendo en cuenta su **referencia** y no su **valor**.

* A. `You are an adult!`
* B. `You are still an adult.`
* C. `Hmm... You don't have an age I guess`
* D. `Ninguna de las anteriores`

**[Ver solución](#sec-sol-array-12)**

---

## Reto #13: Parámetros REST {#sec-array-13}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

**Pista:** Los parámetros REST permiten pasar un número variable de argumentos a una función.

* A. `number`
* B. `array`
* C. `objet`
* D. `NaN`

**[Ver solución](#sec-sol-array-13)**

---

## Reto #14: `typeof` de expresiones extrañas {#sec-array-14}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(typeof([] + []));
```

**Pista:** Recuerda el el operador `+` sirve para hacer concatenaciones de cadenas.

* A. `undefined`
* B. `number`
* C. `object`
* D. `string`

**[Ver solución](#sec-sol-array-14)**

---

## Reto #15: Objetos y conjuntos {#sec-array-15}

::: {.callout-caution title="Dificultad" collapse="true"}
**Avanzado**
:::

**¿Qué imprime este código?**

```js
const obj = { 1: "a", 2: "b", 3: "c" };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty("1");
obj.hasOwnProperty(1);
set.has("1");
set.has(1);
```

**Pista:** Recuerda que un `set` no es lo mismo que un objeto.

* A. `false`, `true`, `false`, `true`
* B. `false`, `true`, `true`, `true`
* C. `true`, `true`, `false`, `true`
* D. `true`, `true`, `true`, `true`

**[Ver solución](#sec-sol-array-15)**

---

## Reto #16: Una curiosidad sobre los objetos {#sec-array-16}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const obj = { a: "one", b: "two", a: "three" };
console.log(obj);
```

**Pista:** Los objetos son estructuras de datos no indexadas.

* A. `{ a: "one", b: "two" }`
* B. `{ b: "two", a: "three" }`
* C. `{ a: "three", b: "two" }`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-16)**

---

## Reto #17: Hablemos sobre prototipos  {#sec-array-17}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
String.prototype.giveLydiaPizza = () => {
  return "Just give Lydia pizza already!";
};

const name = "Lydia";

name.giveLydiaPizza();
```

**Pista:** Los objetos son estructuras de datos no indexadas.

* A. `"Just give Lydia pizza already!"`
* B. `TypeError: not a function`
* C. `SyntaxError`
* D. `undefined`

**[Ver solución](#sec-sol-array-17)**

---

## Reto #18: Simulando asincronía con `setTimeOut()` {#sec-array-18}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"));
const baz = () => console.log("Third");

bar();
foo();
baz();
```

**Pista:** `setTimeout` es una Web API.

* A. `First`, `Second`, `Third`
* B. `First`, `Third`, `Second`
* C. `Second`, `First`, `Third`
* D. `Second`, `Third`, `First`

**[Ver solución](#sec-sol-array-18)**

---

## Reto #19: `typeof` de `typeof` {#sec-array-19}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(typeof typeof 1);
```

**Pista:** `typeof` retorna un primitivo. ¿Pero cuál?

* A. `number`
* B. `string`
* C. `object`
* D. `undefined`

**[Ver solución](#sec-sol-array-19)**

---

## Reto #20: Posiciones indexadas de un arreglo {#sec-array-20}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
```

**Pista:** Los arreglos en JavaScript son muy permisivos.

* A. `[1, 2, 3, 7 x null, 11]`
* B. `[1, 2, 3, 11]`
* C. `[1, 2, 3, 7 x empty, 11]`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-20)**

---

## Reto #21: Entendiendo `reduce` con matrices  {#sec-array-21}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2]
);
```

**Pista:** El segundo parámetro de `reduce` es el valor inicial de `acc`.

* A. `[0, 1, 2, 3, 1, 2]`
* B. `[6, 1, 2]`
* C. `[1, 2, 0, 1, 2, 3]`
* D. `[1, 2, 6]`

**[Ver solución](#sec-sol-array-21)**

---

## Reto #22: El operador de doble negación  {#sec-array-22}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(!!null);
console.log(!!"");
console.log(!!1);
```

**Pista:** El operador `!!` convierte un valor en su equivalente booleano.

* A. `false`, `true`, `false`
* B. `false`, `false`, `true`
* C. `false`, `true`, `true`
* D. `true`, `true`, `false`

**[Ver solución](#sec-sol-array-22)**

---

## Reto #23: Uso de `setInterval` {#sec-array-23}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
setInterval(() => console.log("Hi"), 1000);
```

**Pista:** `setInterval` es una Web API que se ejecuta cada x milisegundos.

* A. `1000`
* B. `Hi 1000 veces`
* C. `Hi cada segundo`
* D. `undefined`

**[Ver solución](#sec-sol-array-23)**

---

## Reto #24: Spread operator con cedenas {#sec-array-24}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log([..."Oscar"])
```

**Pista:** El **spread operator** permite expandir un iterable en sus elementos.

* A. `["O", "s", "c", "a", "r"]`
* B. `["Oscar"]`
* C. `[[], "Oscar"]`
* D. `[["O", "s", "c", "a", "r"]]`

**[Ver solución](#sec-sol-array-24)**

---

## Reto #25: Objeto por referencia {#sec-array-25}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let person = { name: "Carmen" };
const members = [person];
person = null;

console.log(members);
```

**Pista:** Los objetos pasan sus valores por referencia.

* A. `null`
* B. `[null]`
* C. `[{}]`
* D. `[{ name: "Carmen" }]`

**[Ver solución](#sec-sol-array-25)**

---

## Reto #26: El bucle `for...in` con objetos {#sec-array-26}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const person = {
  name: "Carla",
  age: 26
};

for (const item in person) {
  console.log(item);
}
```

**Pista:** El bucle `for...in` no itera sobre los valores de un objeto.

* A. `{ name: "Carla" }`, `{ age: 26 }`
* B. `"name"`, `"age"`
* C. `"Carla"`, `26`
* D. `["name", "Carla"]`, `["age", 26]`

**[Ver solución](#sec-sol-array-26)**

---

## Reto #27: ¿Concatenaciones o sumas aritméticas? {#sec-array-27}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(3 + 4 + "5");
```

**Pista:** Los números se suman, las cadenas se concatenan.

* A. `"345"`
* B. `"75"`
* C. `12`
* D. `75`

**[Ver solución](#sec-sol-array-27)**

---

## Reto #28: Conversiones con `parseInt()` {#sec-array-28}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const num = parseInt("7*6", 10);
console.log(num); 
```

**Pista:** `parseInt()` convierte un número a una base númerica.

* A. `42`
* B. `"42"`
* C. `7`
* D. `NaN`

**[Ver solución](#sec-sol-array-28)**

---

## Reto #29: Transformaciones de arreglos con `map()` {#sec-array-29}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
[1, 2, 3].map(num => {
  if (typeof num === "number") return;
  return num * 2;
});
```

**Pista:** 

* A. `[]`
* B. `[null, null, null]`
* C. `[undefined, undefined, undefined]`
* D. `[ 3 huecos vacíos ]`

**[Ver solución](#sec-sol-array-29)**

---

## Reto #30: Alcance de variables {#sec-array-30}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let x = 10;
if (true) {
  let y = 20;
  var z = 30;
  console.log(x + y + z);
}
console.log(x + z);
```

**Pista:** Diferenciar los diferentes alcances de las variables con `let` y `var`.

* A. `60`, `40`
* B. `undefined`, `10`
* C. `50`, `10`
* D. `null`, `40`

**[Ver solución](#sec-sol-array-30)**

---

## Reto #31: Otra desestructuración de arreglos {#sec-array-31}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const fn = () => {
  return [1000, 9000+1]
}

const [, second] = fn()
console.log(second.toString())
```

**Pista:** Es posible omitir posiciones no deseadas del arreglo usando `,` en la desestructuración.

* A. `1000`
* B. `9001`
* C. `"9001"`
* D. `SyntaxError`

**[Ver solución](#sec-sol-array-31)**

---

## Reto #32: Funciones Tradicionales vs Funciones Flecha {#sec-array-32}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**Explica este código JavaScript**

¿Cuál es la diferencia entre las siguientes funciones?

```js
function addTraditional(a, b){
  return a + b;
}

const addArrow = (a, b) => {
  return a + b;
}
```

**Pista:** No tiene nada que ver con la sintaxis.

* A. `No hay diferencia, son exactamente iguales.`
* B. `La primera función es más rápida que la segunda.`
* C. `La primera función tiene hoisting, la segunda no.`
* D. `Solo cambia la sintaxis, luego son iguales.`

**[Ver solución](#sec-sol-array-32)**

---

## Reto #33: Excepciones con `try...catch` {#sec-array-33}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function greeting() {
  throw "Hello world!";
}

function sayHi() {
  try {
    const data = greeting();
    console.log("It worked!", data);
  } catch (e) {
    console.log("Oh no an error!", e);
  }
}

sayHi();
```

**Pista:** La sentencia `catch` siempre atrapa los errores.

* A. `"It worked! Hello world!"`
* B. `"Oh no an error!" undefined`
* C. `SyntaxError: can only throw Error objects`
* D. `"Oh no an error! Hello world!"`

**[Ver solución](#sec-sol-array-33)**

---

## Reto #34: Spread operator con objetos {#sec-array-34}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
const user = { name: "Hernan", age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
```

**Pista:** El **spread operator** expande las propiedades del objeto. 

* A. `{ admin: true, user: { name: "Hernan", age: 21 } }`
* B. `{ admin: true, name: "Hernan", age: 21 }`
* C. `{ admin: true, user: ["Hernan", 21] }`
* D. `{ admin: true }`

**[Ver solución](#sec-sol-array-34)**

---

## Reto #35: El segundo parámetro de `JSON.stringify` {#sec-array-35}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const settings = {
  username: "asterion",
  level: 80,
  health: 25
};

const data = JSON.stringify(settings, ["level", "health"]);
console.log(data);
```

**Pista:** `JSON.stringify` convierte un objeto a cadena. 

* A. `'{"level":80, "health":25}'`
* B. `'{"username": "asterion"}'`
* C. `'["level", "health"]'`
* D. `'{"username": "asterion", "level":80, "health":25}'`

**[Ver solución](#sec-sol-array-35)**

---

## Reto #36: Alcance de variables y paso de parámetros {#sec-array-36}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
```

**Pista:** La variable `num` tiene alcance global.

* A. `10`, `10`
* B. `10`, `11`
* C. `11`, `11`
* D. `11`, `12`

**[Ver solución](#sec-sol-array-36)**

---

## Reto #37: Multiples llamadas a una función {#sec-array-37}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log((x.number *= 2));
};

multiply();
multiply();
multiply(value);
multiply(value);
```

**Pista:** Diferenciar entre las referencias de un objeto como parámetro en una función.

* A. `20`, `40`, `80`, `160`
* B. `20`, `40`, `20`, `40`
* C. `20`, `20`, `20`, `40`
* D. `NaN`, `NaN`, `20`, `40`

**[Ver solución](#sec-sol-array-37)**

---

## Reto #38:  {#sec-array-38}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
console.log(Number(2) === Number(2))
console.log(Boolean(false) === Boolean(false))
console.log(Symbol('foo') === Symbol('foo'))
```

**Pista:** Cuidado con las comparaciones entre primitivos `Symbol`.

* A. `true`, `true`, `false`
* B. `false`, `true`, `false`
* C. `true`, `false`, `true`
* D. `true`, `true`, `true`

**[Ver solución](#sec-sol-array-38)**

---

## Reto #39: Funciones asíncronas {#sec-array-39}

::: {.callout-caution title="Dificultad" collapse="true"}
**Intermedio**
:::

**¿Qué imprime este código?**

```js
async function getData() {
  return await Promise.resolve("I made it!");
}

const data = getData();
console.log(data);
```

**Pista:** Las promesas son objetos especiales de JavaScript que solo tienen tres posibles estados: promesa resuelta, promesa rechazada o promesa pendiente.

* A. `"I made it!"`
* B. `Promise {<resolved>: "I made it!"}`
* C. `Promise {<pending>}`
* D. `undefined`

**[Ver solución](#sec-sol-array-39)**

---

## Reto #40:  {#sec-array-40}

::: {.callout-caution title="Dificultad" collapse="true"}
**Básico**
:::

**¿Qué imprime este código?**

```js
function addToList(item, list) {
  return list.push(item);
}

const result = addToList("apple", ["banana"]);
console.log(result);
```

**Pista:** ¿El método `push` de los arreglos solo agrega un elemento al final de un arreglo?

* A. `['banana', 'apple']`
* B. `2`
* C. `true`
* D. `undefined`

**[Ver solución](#sec-sol-array-40)**

---